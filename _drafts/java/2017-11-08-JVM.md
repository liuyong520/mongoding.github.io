---
layout: post
title: JVM
subtitle: 掌握JVM内存结构、类加载与垃圾回收机制及其优化
date: 2017-11-08
author: chengweii
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - JVM
    - java
---

Java虚拟机一直是Java的重难点，一方面由于系统封装得太好，你平常写程序的时候几乎感觉不到它的存在，另一方面了解必要的Java虚拟机工作原理才能对真实工作环境下的bug进行对症下药，另外虚拟机这一部分也一直是面试考官爱问的问题。于是这篇博客就针对Java虚拟机的各个知识点进行归纳。

## 一.Java内存区域

　**　运行时数据区域**

[![](http://img.blog.csdn.net/20160529183400922)]()

　　**程序计数器**

　　程序计数器是当前线程执行的字节码的行号指示器，线程私有，独立存储

　　**Java虚拟机栈**

　　Java虚拟机栈是线程私有，与Java的方法执行模型有关，描述Java方法执行的内存模型:方法执行时创建栈帧，用于储存局部变量，表操作数栈，动态链接，方法出入口等信息。方法调用返回对应栈帧再虚拟机中的入栈出栈。
		这里解释一下局部变量表，局部变量表存储方法相关的局部变量，包括基本数据，对象引用和返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。

　　既然是栈那么深度就是一定的，若线程请求栈深度大于虚拟机所规定的深度，则抛出StackOverflowError异常。若虚拟机栈请求扩展时无法申请到足够的内存，则抛出OOM异常。

　　**本地方法栈**

　　就是Native方法所用到的栈，与虚拟机栈作用类似。

　　**Java堆**

　　Java堆是被所有线程共享的一块内存区域，属于线程共享区，在虚拟机启动时创建。它主要作用是存放对象实例和进行垃圾收集管理。堆中没有内存完成实例分配，并且堆无法扩展的时候，将会抛出OutOfMemoryError异常。

　　**方法区**

　　方法区也是各个线程共享的内存区域，用于储存已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。方法区在物理上也是不需要连续的，可以选择固定大小或者扩展的大小，还可以选择不实现垃圾收集，方法区的垃圾回收是比较少的，这就是方法区为什么被称为永久区的原因，但是方法区也是可以执行回收的，该区域主要是针对常量池和类型的卸载；在方法区也规定当方法区无法满足内存分布的时候，将会抛出OutOfMemoryError异常；

　**　运行时常量池**

　　运行时常量是方法区的一部分，常量池主要用于存放编译生成的各种字面量和符合引用，由于常量池属于方法区的一部分，所以当常量池没有内存空间的时候就抛出OutOfMemoryError异常；

　**　new关键字的创建流程**

　　1、检查指令的参数能否在常量池中定位到一个类的符号引用

　　2、检查是否已经加载解析和初始化

　　3、从Java堆中划分内存给新生对象，使用CAS保证分配的原子性

　　4、将内存空间初始化为零值

　　5、对对象进行设置，存放在对象头中

　　6、执行方法，按照程序员的意愿进行初始化

　**　分配方式**

　　1、指针碰撞

　　若Java堆中的内存都是规整的，用过的内存都在左边，没用过的都在右边，中间指针指向临界点，分配内存就很简单，只用把指针往右移动和待分配对象一样的内存区域就行了。

　　2、空闲列表

　　如果内存不是规整的，用过的和没用过的内存交错在一起，就不能使用指针碰撞了，需要维护一个列表[**记录**](javascript:;)可用的内存块，分配内存时就从列表中找一块足够大的内存记录下来。

　　**对象的内存布局**

**　　对象头**

　　储存对象自身的运行时数据，eg：哈希码，GC分代年龄，锁状态标志等。还有类型指针指向它的类元数据的指针，通过这个指针确定这个对象是哪个类的实例。若是Java数组则对象头还有一块记录数组长度的数据。

　　**实例数据**

　　程序代码中所定义的各种类型的字段内容，相同宽度的字段分配到一起

　　**对象访问定位**

　　虚拟机通过栈上的reference数据来操作堆上的具体对象。

　　**访问方式**

　　1、使用句柄

　　包含对象实例数据与类型数据各自的地址信息，reference中储存的就是对象的句柄地址。句柄地址稳定，对象移动时只改变句柄中的实例数据指针，reference本身不修改。

　　2、直接指针

　　reference中储存的就是对象地址，速度更快

## 二.垃圾收集器与内存分配策略

**　　引用计数算法**

　　给对象添加一个引用计数器，有一个地方引用它时，计数器值就加一，引用失效时就减一，任何时刻计数值为0的对象就死了。这个算法虽然简单但是有一个致命的缺点就是无法解决对象之间相互循环引用的关系。可达性分析算法应运而生。

　**　可达性分析算法**

　　GC Roots作为起点向下搜索，若一个对象到GC Roots没有引用链的话，则证明此对象不可用，可以回收。搜索的对象有：

　　· 虚拟机栈中引用的对象

　　· 方法区中静态属性引用的对象

　　· 方法区中常量引用的对象

　　· 本地方法栈中Native 方法引用的对象

　　**对象的回收经历**

　　对象在没有引用链通往GC Roots时，需要经过两次标记才能真正死亡。

　　对象在进行可达性分析后如果没有与GC Roots相连接的引用链，会被第一次标记并筛选，若对象没有覆盖finalize方法或者已经调用过了则不会调用finalize。如果需要调用finalize方法，则对象被放在F-Queue队列中，等待线程执行。

　　对象如果想存活下去，finalize方法是最后的机会，否则GC对F-Queue队列进行第二次标记后对象真正死亡。

　　**垃圾回收算法**

**　　标记-消除算法**

　　首先标记出所有需要回收的对象，在标记完成后统一回收，缺点是效率低下而且产生大量的内存碎片。

　　**复制算法**

　　将内存划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后把已经使用的内存空间一次清理掉。缺点是将内存缩小为了原来的一半，代价较高，对象存活率较高时效率低。

　　HotSpot实际使用（回收新生代）则是将内存划分为较大的Eden区和两块较小的Survivor区，一块Eden区和一块Survivor区大小比例为8:1，垃圾回收时就将Eden区和已使用的Survivor区中还存活的对象移到另一块Survivor区中，由于根据统计，98%的对象都是很快死亡的，所以按照8:1:1的比例来划分内存明显比1:1划分内存效率要高很多。

　**　标记-整理算法**

　　标记出需要回收的对象，然后让所有存活的对象都向一段移动，将另一端的内存区域清除掉。

　　**分代收集算法**

　　根据新生代和老年代的不同特点选择不同的算法，新生代使用复制算法，老年代使用标记清楚或标记整理算法，虚拟机实际使用这种算法。

　　**内存分配与回收策略**

**　　对象优先在Eden上分配**

　　**GC分类**

　　1、Monior GC，新生代GC，指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特点，所以Monior GC很频繁，速度也很快

　　2、Major GC/Full GC，老年代GC，指发生在老年代的垃圾回收动作，一般比Monior GC慢十倍以上。

　　**大对象直接进入老年代**

　　大对象指需要大量连续内存空间的Java对象，如很长的字符串以及数组。直接进入老年代避免频繁的GC活动。

　　**长期存活的对象将进入老年代**

　　对象在新生代区域每熬过一次Minor GC，年龄就增加一岁（Age Count），超过15岁（默认），就会被晋升到老年代中。

　　**动态年龄判定**

　　如果相同年龄的对象所占内存大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。
		**分代搜集过程**
   1.当一个对象被创建的时候(new)首先会在年轻代的Eden区被创建，直到当GC的时候，根据可达性算法，看一个对象是否消亡，没有消亡的对象会被放入年轻带的Survivor区，消亡的直接被Minor GC Kill掉；

   2.进入到Survivor区的对象也不是安全的，当下一次Minor GC来的时候还是会检查Enden和Survivor存放对象区域中对象是否存活，存活放入另外一块Survivor区域；

   3.当2个Survivor区切换几次以后，会直接进入老年代，当然进入到老年代也不是安全的，当老年代内存空间不足的时候，会触发Major GC,已经消亡的依然还是被Kill掉

　　**三.类文件结构**

　　**Class类文件的结构**

　　一组以八位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有任何分隔符。

　　**储存结构**

　　无符号数，用来描述数字，索引引用，数量值或UTF-8编码的字符串

　　表，多个无符号数+表=表，_info结尾，Class实际上就是一张表

　　**魔数**

　　每个Class文件的头4个字节，确定这个文件是否为一个能被虚拟机接受的Class文件。class文件的魔数是0XCAFEBABE。

　　**Class文件的版本号**

　　紧跟魔数的四个字节确定版本号：5，6字节为次版本号，7，8字节为主版本号。jdk向下兼容，不向上兼容。

　　**常量池**

　　紧随主次版本号之后包含：

　　· 字面量文本字符串，申明为final的常量值。

　　· 符号引用

　　类和接口的全限定名

　　字段的名称和描述符

　　方法的名称和描述符

　　· 动态连接各个字段的内存信息，从常量池中获得对应的读出引用，再在类创建时或运行解析翻译到具体的内存地址之中。

　　· 每一项常量都是一个表，每个表的第一位都是一个是一个u1类型的标志位，代表这个常量属于哪种常量类型。

　　**访问标志**

　　紧随常量池后面，两个字节代表访问标志，标识类或接口的访问信息。如这个Class是类还是接口，public类型等。

　　**类索引，父类索引，接口索引集合**

　　除了接口索引是集合外，其他索引都只有一个，用这三个索引确定类的继承关系。类索引用于确定类的全限定名，父类索引用于确定父类的全限定名。

　　**字段表集合**

　　用于描述类或接口中声明的变量，字段包括类级变量和实例级变量，不包括方法中声明的局部变量，描述字段的属性如public，static，final等用一个布尔变量表示，刚好使用一个标志位，通过引用常量池中的常量来确定。

　　**方法表集合**

　　与字段表相似。

　　**属性表集合**

　　Class文件，字段表，方法表都可以携带自己的属性表集合，用于描述某些场景专有的信息。

　　**字节码指令**

　　操作码长度为一个字节，所以总数最多不超过256条。。



**　一.虚拟机类加载机制**

**　　概述**

　　虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

　　**类加载的时机**

　　类加载的时机不止一种：

　　· 遇到new等字节码指令时会进行类加载

　　· 反射调用时会进行类加载

　　在初始化时，若待初始化的类有父类则其父类先进行初始化(接口除外),并且先初始化包含main的主类。需要注意的是子类引用父类非final静态变量时，只初始化静态变量所在类，即父类，而引用final类型static变量不会引起任何初始化，因为其编译期间就已经储存在常量池中了。另外数组定义也是不会引发类的初始化。比如

　　Student[] stus=new Student[10];

　　是不会引起Student类的初始化的。

　　**类加载的过程**

**　　加载过程**

　　通过类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构，在内存中生成一个代表类的数据访问入口的java.lang.Class对象。

　　**验证过程**

　　验证过程的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要有

　　· 文件格式验证：验证魔数，主次版本号，常量类型等。

　　· 元数据验证：是否有父类，是否继承了不该继承的类，抽象类是否实现了方法等。

　　· 字节码验证：确保程序语义是合法的，符合逻辑的。如类型转换，跳转指令等。

　　· 符号引用验证：对类自身以外的信息（常量池中的各种引用）进行匹配校验。

　　**准备过程**

　　正式为类变量分配内存并设置类变量初始值的阶段,只包括类变量而不包括实例变量和final类变量，而且仅仅只是初始化为0值。

　　**解析过程**

　　虚拟机将常量池内的符号引用转换为直接引用的过程。符号引用用一组符号来描述所引用的目标。而直接引用是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。

　　**初始化阶段**

　　在初始化阶段真正开始执行Java程序代码（字节码），执行类的构造器<clinit>()方法,<clinit>()方法是由编译器自动收集所有类变量的赋值动作和静态语句块的语句合并而成,同一类中的静态块与类变量按顺序初始化,在同一个加载器下，一个类只会被初始化一次。

　　**类加载器**

　　实现通过一个类的全限定名获取描述此类的二进制字节流的代码模块称为类加载器。比较两个类是否相等，一定是在同一个类加载器的前提下进行的，否则哪怕Class文件都一样也不相等

　　**类加载器的分类**

　　启动类加载器， 负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。

　　扩展类加载器，负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。

　　应用程序类加载器，负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

　**　双亲委派模型**

[![](http://www.51testing.com/attachments/2018/02/14982672_201802141001541FXxr.png)](http://www.51testing.com/batch.download.php?aid=82879)

　　双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。

　　这样做的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。

　**　二.虚拟机字节码执行引擎**

　　虚拟机的执行引擎自行实现，可以自行制定指令集与执行引擎的结构体系。

　　**栈帧**

　　栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机栈的栈元素。它储存了方法的局部变量表，操作数栈，动态链接，方法返回地址，对于活动线程来说，只有栈顶的栈帧才是有效的，称为当前栈帧，与其关联的方法叫做当前方法。

　**　局部变量表**

　　局部变量表存放方法参数和方法内部定义的变量。单位是slot（槽），最大可以达到32位。垃圾回收时，slot可以复用，将不使用的变量置为null是有意义的，方便垃圾回收。局部变量不像类变量，是没有初始值的。

　　**JIT编译器**

　　当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为 “Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是 JIT 编译器。

　　**方法返回地址**

　　遇到方法的返回指令-->正常完成出口

　　遇到异常并且未处理-->异常完成出口，不会给上层调用者产生任何返回值

　　**方法调用**

　　方法在编译时并不确定方法的真实地址，而是一个符号引用，使得Java的动态扩展能力提升，在类加载过程甚至运行时才确定目标方法的直接引用。

　　**解析**

　　在类的解析阶段将一部分符号引用转换为直接引用，这部分符号引用代表的方法必须“编译期可知，运行时不变”，如静态方法，私有方法，实例构造器，父类方法。final方法也是。

　　**分派**

　　静态分派(与重载相关)，依赖静态类型来定位方法执行版本的分派动作。自动转型顺序：char->int->long->float->double->Character->Serializable->Object->char...

　　动态分派(重写相关)，找到操作数栈顶的第一个元素所指向的对象的实际类型，若常量池中的描述符和简单名称都相符，则返回直接引用，否则对其父类进行第二步。

　　动态分配的实现：

[![](http://www.51testing.com/attachments/2018/02/14982672_201802141001542f7Xa.png)](http://www.51testing.com/batch.download.php?aid=82880)

　　在类的方法区建立一个虚方法表提升效率，若子类未重写父类的方法，则子类的继承方法中地址和父类方法的地址是一样的，若重写了父类的方法，则子类的方法地址就会改变，指向自己实现的版本。如上图Son的clone方法没有被重写，指向的是Object父类的地址，而hardChoice方法被重写了，指向的是Son自己实现的地址。

　**　动态类型语言**

　　类型检查的主题过程在运行期而不是在编译期，如[**Python**](javascript:;)，Javascript，[**Ruby**](javascript:;)，PHP，与之相对的就是静态语言。

　　· 解释执行与编译执行

　　· 解释执行为边解释边执行，编译执行则是先将源代码编译成目标语言 (如: 机器语言) 之后通过连接程序连接到生成的目标程序进行执行。

　　基于栈的字节码解释执行引擎

　　基于栈的指令集：Java编译器输出的指令流

　　基于寄存器的指令集：x86汇编

　**　三.早期编译器优化**

　**　编译器**

　　三种编译器：

　　· 前端编译器:把*.java变成*.class的过程，eg:Javac

　　· 后端运行期编译器(JIT)：把字节码变成机器码的过程,eg:Hotpot的C1，C2编译器

　　· 静态提前编译器(AOT):直接把*.java变成机器码的过程，eg:GCJ(GNU Compiler for the Java)

　　**解析与填充符号表**

**　　词法分析**

　　标记是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，词法分析就是将源代码的字符流转变为标记集合。

　**　语法分析**

　　语法分析是根据Token序列构造抽象语法树的过程。抽象语法树是用来描述程序代码语法结构的树形表示方法，每一个节点都代表着程序代码的一个语法结构：包，类型，修饰符等。

　　**注解处理器**

　　类似编译器的一种插件，如果插件对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理。

　　**语义分析**

　　对语法抽象树进行上下文有关性质的审查，如类型检查。

　**　字节码生成**

　　将前面各个步骤生成的信息转换成字节码写到磁盘中，类构造器<cinit>和实例构造器<init>就是在这个阶段添加到语法树中。

　　**Java语法糖**

　　· 泛型与类型擦除:与C#不一样，Java的泛型是伪泛型，在生成的字节码中已经被替换成了原生类型了，会自动加上类型转换。

　　· 遍历:自动转换为iterator遍历。

　　· 装箱与拆箱:==运算在不遇到算数运算的情况下不会自动拆箱。equals方法不会处理数据的类型转换，而==会。

　**　条件编译**

　　编译器不会编译if到达不到的语句，也就是取消分支不成立的代码块，可以查看反编译后的代码验证条件编译。

**一.晚期运行期优化**

**　　即时编译器JIT**

　　即时编译器JIT的作用就是热点代码转换为平台相关的机器码，并进行优化，它并不是一个虚拟机所必须的部分，只能说有它是锦上添花。

　　**热点代码**

**　　热点代码分类**

　　· 被多次调用的方法

　　· 被多次调用的循环体

　　**热点探测判定方法**

　　· 基于采样的热点探测，虚拟机周期性地检查栈顶，发现某个方法经常出现在栈顶，那么这个方法就是热点方法，简单高效但不精确

　　· 基于计数器热点探测，为每个方法建立计数器来统计执行次数，超过阈值就是热点方法，Hotpot就是采用这种方法。分为方法计数器（统计方法），回边计数器（统计循环）

　
**　　二.Java内存模型与线程**

**　　内存模型**

　　说了这么多的内存模型，到底什么是内存模型呢？

　　特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

　　它的作用是定义程序中各个共享的变量的访问规则，即如何将变量写入内存和从内存中取出变量。Java内存模型有主内存与工作内存之分，所有变量存在主内存中，线程则是拥有自己的工作内存，它是主内存的副本拷贝，线程只能读写工作内存。

　　**8种原子操作**

　　· lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。

　　· unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

　　· read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。

　　· load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。

　　· use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。

　　· assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

　　· store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。

　　· write（写入）：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

　**　volatile变量的特殊规则**

　　volatile的特性是保证此变量对所有线程的可见性，即当变量的值修改后，其他线程可以立即知道发生的变化。普通变量则是修改完值后，需要写回主内存，然后其他线程再从主内存读取该数据。volatile还可以通过内存屏障来禁止指令的重排序。综合来讲它的读操作和普通变量差不多，写操作慢一点。

　　**long和double变量的特殊规则**

　　8种操作一般都是原子性的，但是对于64位的数据，内存模型允许将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作进行---->非原子协定但一般我们不需要将long和double声明为volatile。

　

　　**Java与线程**

　　Java的Thread类大多API都是Native方法，是与平台相关的。

　　**实现线程的三种方式**

　　· 使用内核线程实现：内核线程即直接由[**操作系统**](javascript:;)内核支持的线程，由内核来完成线程切换，程序使用轻量级进程接口与内核线程一对一的关系，内核线程再经由线程调度器分派给CPU。

　　· 使用用户线程实现：用户线程的建立同步销毁调度完全在用户态中完成，不需切换到内核态，一对多的关系。

　　· 用户线程+轻量级进程：多对多的关系。

　　**线程的调度**

**　　协同式调度**

　　线程的执行时间由线程自己控制，执行完后再主动通知系统切换线程，可能会导致一个线程长时间地阻塞

　**　抢占式调度**

　　由系统分配时间，线程可以主动让出时间但是不能主动获得时间，通过设置优先级确定顺序

　**　线程的状态**

　　· 新建：刚刚创建还未启动

　　· 运行：正在执行或者等待分配时间

　　· 无限等待：不会被CPU分配时间，需要其他线程显式唤醒

　　· 有限等待：在一段时间后由系统自动唤醒

　　· 阻塞：等待一个排他锁

　　· 结束

　**　三.线程安全与锁优化**

　**　线程安全的程度，依次减弱**

　　· 不可变，将对象中带状态的变量都置为final

　　· 绝对线程安全，完全符合线程安全定义

　　· 相对线程安全，对这个对象的单独的操作是线程安全的，如Vector，HashTable等

　　· 线程兼容，对象本身不是线程安全的，但是可以在调用端正确地使用同步手段才能保证在并发环境下正常使用。

　　· 线程对立，无论调用端如何努力，都不可能实现线程安全

　　**线程安全的实现方法**

　　1、**互斥同步**

　　synchronized关键字会在代码块的前后分别形成monitorenter和monitorexit指令，这两个指令需要一个reference对象参数，该锁有一个计数器以实现同步，进入时将计数器+1，退出时-1，本线程可重入，其他线程需阻塞等待。synchronized的缺点是由于Java线程是映射到操作系统的，所以唤醒阻塞一个线程都需要系统帮忙，需要从用户态转到内核态，耗费很多处理器时间。

　　ReentrantLock对synchronized的优势：

　　· 等待可中断

　　· 公平锁：必须按照申请锁的时间顺序来一次获得锁

　　· 锁绑定多个条件

　　2、**非阻塞同步**

　　为了解决线程阻塞和唤醒所带来的性能问题，先对共享数据进行操作，如果没有竞争就成功了，否则就补偿（不断重试直到成功）

　　**3、无同步方案**

　　· 可重入代码

　　· 线程本地存储，把共享数据的范围限制到线程内，ThreadLocalMap以ThreadLocalHashMap为键,以本地线程变量为值的K-V对

　　**锁优化**

　　锁优化的方案有以下几种：

　　· 自旋锁：为了减少线程阻塞与唤醒的消耗，线程在被阻塞时可以执行一个忙循环（自旋）

　　· 锁消除：对不存在共享数据竞争的锁进行消除

　　· 锁粗化：在一个代码块内对一个对象连续的地加锁解锁，就对整个代码块一次性加锁减少性能损耗

　　· 轻量级锁：无竞争地情况下使用CAS操作去消除同步使用地互斥量

　　· 偏向锁：锁会偏向于第一个获得它地线程

## **1、垃圾收集器概述**

> 垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别，本文主要介绍HotSpot虚拟机中的垃圾收集器。

### **1-1、垃圾收集器组合**

> JDK7/8后，HotSpot虚拟机所有收集器及组合（连线），如下图：

![](https://img-blog.csdn.net/20170102225015393)

> （A）、图中展示了**7种**不同分代的收集器：
> 
>        Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；
> 
> （B）、而它们所处区域，则表明其是属于新生代收集器还是老年代收集器：
> 
> **      新生代收集器**：Serial、ParNew、Parallel Scavenge；
> 
> **      老年代收集器**：Serial Old、Parallel Old、CMS；
> 
> **      整堆收集器**：G1；
> 
> （C）、两个收集器间有连线，表明它们**可以搭配使用**：
> 
>        Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；
> 
> （D）、其中Serial Old作为CMS出现**"Concurrent Mode Failure"失败**的后备预案（后面介绍）；

### **1-2、并发垃圾收集和并行垃圾收集的区别**

> **（A）、并行（Parallel）**
> 
>        指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；
> 
>        如**ParNew、Parallel Scavenge、Parallel Old**；
> 
> **（B）、并发（Concurrent）**
> 
>        指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；
> 
>       用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；    
> 
>        如**CMS、G1**（也有并行）；

### **1-3、Minor GC和Full GC的区别**

> **（A）、Minor GC**
> 
>        又称**新生代GC**，指发生在新生代的垃圾收集动作；
> 
>        因为Java对象大多是朝生夕灭，所以Minor GC非常频繁，一般回收速度也比较快；
> 
> **（B）、Full GC**
> 
>        又称**Major GC或老年代GC**，指发生在老年代的GC；
> 
>        出现Full GC经常会伴随至少一次的Minor GC（不是绝对，Parallel Sacvenge收集器就可以选择设置Major GC策略）；
> 
>       Major GC速度一般比Minor GC慢10倍以上；

> 下面将介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器；但需要明确一个观点：
> 
>        没有最好的收集器，更没有万能的收集；
> 
>       选择的只能是适合具体应用场景的收集器。

## **2、Serial收集器**

> Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；
> 
>        JDK1.3.1前是HotSpot新生代收集的唯一选择；
> 
> **1、特点**
> 
>       针对新生代；
> 
>       采用复制算法；
> 
>       单线程收集；
> 
>        进行垃圾收集时，必须暂停所有工作线程，直到完成；            
> 
>        即会"Stop The World"；
> 
> **      Serial/Serial Old组合收集器运行示意图如下：**

![](https://img-blog.csdn.net/20170102225015841)

> **2、应用场景**
> 
>       依然是HotSpot在Client模式下默认的新生代收集器；
> 
>       也有优于其他收集器的地方：
> 
> > 简单高效（与其他收集器的单线程相比）；
> > 
> >       对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；
> > 
> >       在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的
> 
> **3、设置参数**
> 
> **      "-XX:+UseSerialGC"**：添加该参数来显式的使用串行垃圾收集器；
> 
> ******4、Stop TheWorld说明******
> 
>       JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即**GC停顿**；
> 
>       会带给用户不良的体验；
> 
> > 从JDK1.3到现在，从Serial收集器-》Parallel收集器-》CMS-》G1，用户线程停顿时间不断缩短，但仍然无法完全消除；
> 
>       更多"Stop The World"信息请参考：[《Java虚拟机垃圾回收(一) 基础》](http://blog.csdn.net/tjiyu/article/details/53982412)"2-2、可达性分析算法"
> 
> 更多Serial收集器请参考：
> 
>       《Memory Management in the Java HotSpot™ Virtual Machine》 4.3节 Serial Collector（内存管理白皮书）：[http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)
> 
>       《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》 第5节 Available Collectors（官方的垃圾收集调优指南）：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref27](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref27)[](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html%23sthref27)

## **3、ParNew收集器**

> ParNew垃圾收集器是**Serial收集器的多线程版本**。
> 
> **1、特点**
> 
>       除了多线程外，其余的行为、特点和Serial收集器一样；
> 
>       如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；
> 
>       两个收集器共用了不少代码；
> 
> **      ParNew/Serial Old组合收集器运行示意图如下：**

![](https://img-blog.csdn.net/20170102225016331)

> **2、应用场景**
> 
>       在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它**能与CMS收集器配合工作**；
> 
>       但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。
> 
> **3、设置参数**
> 
> **      "-XX:+UseConcMarkSweepGC"**：指定使用CMS后，会默认使用ParNew作为新生代收集器；
> 
> **      "-XX:+UseParNewGC"**：强制指定使用ParNew；    
> 
> **      "-XX:ParallelGCThreads"**：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；
> 
> **4、为什么只有ParNew能与CMS收集器配合**
> 
>       CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；
> 
>       CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；
> 
>       因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；
> 
>       关于CMS收集器后面会详细介绍。

## **4、Parallel Scavenge收集器**

> Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为**吞吐量收集器（Throughput Collector）**。
> 
> **1、特点**
> 
> > **（A）、**有一些特点与**ParNew收集器相似**
> > 
> >       新生代收集器；
> > 
> >       采用复制算法；
> > 
> >       多线程收集；
> > 
> > **（B）、主要特点是：它的关注点与其他收集器不同**
> > 
> >       CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间；
> > 
> >       而Parallel Scavenge收集器的目标则是**达一个可控制的吞吐量（Throughput）**；
> > 
> > **      关于吞吐量与收集器关注点说明详见本节后面；**

> **2、应用场景**
> 
>       高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间；
> 
>       当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在**后台进行计算，而不需要与用户进行太多交互**；
> 
>       例如，那些**执行批量处理**、订单处理、工资支付、科学计算的应用程序；
> 
> **3、设置参数**
> 
>       Parallel Scavenge收集器提供两个参数用于精确控制吞吐量：
> 
> > **（A）、"-XX:MaxGCPauseMillis"**
> > 
> >       控制最大垃圾收集停顿时间，大于0的毫秒数；
> > 
> >       MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降；
> > 
> >       因为可能导致垃圾收集发生得更频繁；
> > 
> > **（B）、"-XX:GCTimeRatio"**
> > 
> >       设置垃圾收集时间占总时间的比率，0<n<100的整数；
> > 
> >       GCTimeRatio相当于设置吞吐量大小；
> > 
> >       垃圾收集执行时间占应用程序执行时间的比例的计算方法是：
> > 
> > > 1 / (1 + n)
> > > 
> > >       例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5%--1/(1+19)；
> > 
> >       默认值是1%--1/(1+99)，即n=99；

> > 垃圾收集所花费的时间是年轻一代和老年代收集的总时间；
> > 
> > 如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；
> 
>       此外，还有一个值得关注的参数：

> > **（C）、"-XX:+UseAdptiveSizePolicy"**
> > 
> >       开启这个参数后，就不用手工指定一些细节参数，如：
> > 
> > > 新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等；
> > 
> >       JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为**GC自适应的调节策略（GC Ergonomiscs）**；

> > **      这是一种值得推荐的方式**：
> > 
> > > (1)、只需设置好内存数据大小（如"-Xmx"设置最大堆）；
> > > 
> > >       (2)、然后使用"-XX:MaxGCPauseMillis"或"-XX:GCTimeRatio"给JVM设置一个优化目标；
> > > 
> > >       (3)、那些具体细节参数的调节就由JVM自适应完成；
> > 
> >       这也是Parallel Scavenge收集器与ParNew收集器一个重要区别；
> 
>       更多目标调优和GC自适应的调节策略说明请参考：

> 《Memory Management in the Java HotSpot™ Virtual Machine》 5节 Ergonomics -- Automatic Selections and Behavior Tuning：[http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)
> 
>       《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》 第2节 Ergonomics：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#ergonomics](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html%23ergonomics)

> **4、吞吐量与收集器关注点说明**

> > **（A）、吞吐量（Throughput）**
> > 
> >       CPU用于运行用户代码的时间与CPU总消耗时间的比值；
> > 
> >       即**吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）；**    
> > 
> >       高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间；
> > 
> > **（B）、垃圾收集器期望的目标（关注点）**
> > 
> > > **（1）、停顿时间    **
> > > 
> > >       停顿时间越短就适合需要与用户交互的程序；
> > > 
> > >       良好的响应速度能提升用户体验；
> > > 
> > > **（2）、吞吐量**
> > > 
> > >       高吞吐量则可以高效率地利用CPU时间，尽快完成运算的任务；
> > > 
> > >       主要适合在后台计算而不需要太多交互的任务；
> > > 
> > > **（3）、覆盖区（Footprint）**
> > > 
> > >       在达到前面两个目标的情况下，尽量减少堆的内存空间；
> > > 
> > >       可以获得更好的空间局部性；
> 
> 更多Parallel Scavenge收集器的信息请参考：
> 
>       官方的垃圾收集调优指南 第6节：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#parallel_collector](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html%23parallel_collector)
> 
>  [](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html%23parallel_collector) 
> 
> **上面介绍的都是新生代收集器，接下来开始介绍老年代收集器；** [](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html%23parallel_collector)

## **5、Serial Old收集器**

> Serial Old是** Serial收集器的老年代版本**；
> 
> **1、特点**
> 
>       针对老年代；
> 
>       采用"标记-整理"算法（还有压缩，Mark-Sweep-Compact）；
> 
>       单线程收集；
> 
>       Serial/Serial Old收集器运行示意图如下：

![](https://img-blog.csdn.net/20170102225016763)

> **2、应用场景**
> 
>       主要用于Client模式；
> 
>       而在Server模式有两大用途：
> 
> > （A）、在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）；
> > 
> >       （B）、作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用（后面详解）；
> 
> 更多Serial Old收集器信息请参考：
> 
>       内存管理白皮书 4.3.2节：[http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

## **6、Parallel Old收集器**

> Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本；
> 
>       JDK1.6中才开始提供；
> 
> **1、特点**
> 
>       针对老年代；
> 
>       采用"标记-整理"算法；
> 
>       多线程收集；
> 
> **      Parallel Scavenge/Parallel Old收集器运行示意图如下：**

![](https://img-blog.csdn.net/20170102225017065)

> **2、应用场景**
> 
>       JDK1.6及之后用来代替老年代的Serial Old收集器；
> 
>       特别是在Server模式，多CPU的情况下；
> 
>       这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的"给力"应用组合；
> 
> **3、设置参数**
> 
> **      "-XX:+UseParallelOldGC"：指定使用Parallel Old收集器；**
> 
> 更多Parallel Old收集器收集过程介绍请参考：
> 
>       《内存管理白皮书》 4.5.2节：    [    http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf](https://blog.csdn.net/tjiyu/article/details/53983650)

## **7、CMS收集器**

> 并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器；
> 
>       在前面ParNew收集器曾简单介绍过其特点；
> 
> **1、特点**
> 
>       针对老年代；
> 
>       基于"标记-清除"算法(不进行压缩操作，产生内存碎片)；            
> 
>       以获取最短回收停顿时间为目标；
> 
>       并发收集、低停顿；
> 
>       需要更多的内存（看后面的缺点）；
> 
>       是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器；
> 
>       第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；
> 
> **2、应用场景**
> 
> **      与用户交互较多的场景**；        
> 
>       希望系统停顿时间最短，注重服务的响应速度；
> 
>       以给用户带来较好的体验；
> 
>       如**常见WEB、B/S系统的服务器上的应用**；

> **3、设置参数**
> 
> **"-XX:+UseConcMarkSweepGC"：指定使用CMS收集器；**
> 
> ********4、CMS收集器运作过程********
> 
>       比前面几种收集器更复杂，可以分为4个步骤:

> > **（A）、初始标记（CMS initial mark）**
> > 
> >       仅标记一下GC Roots能直接关联到的对象；
> > 
> >       速度很快；
> > 
> >       但需要"Stop The World"；
> > 
> > **（B）、并发标记（CMS concurrent mark）**
> > 
> >       进行GC Roots Tracing的过程；
> > 
> >       刚才产生的集合中标记出存活对象；
> > 
> >       应用程序也在运行；
> > 
> >       并不能保证可以标记出所有的存活对象；
> > 
> > **（C）、重新标记（CMS remark）**
> > 
> >       为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；
> > 
> >       需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；
> > 
> >       采用多线程并行执行来提升效率；
> > 
> > **（D）、并发清除（CMS concurrent sweep）**
> > 
> >       回收所有的垃圾对象；

> 整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作；
> 
>       所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行；
> 
> **      CMS收集器运行示意图如下：**

![](https://img-blog.csdn.net/20170102225017372)

**        5、CMS收集器3个明显的缺点**

**                     （A）、对CPU资源非常敏感**

> > 并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。
> > 
> > **      CMS的默认收集线程数量是=(CPU数量+3)/4；**
> > 
> >       当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。
> > 
> > **      增量式并发收集器：**
> > 
> > > 针对这种情况，曾出现了"增量式并发收集器"（Incremental Concurrent Mark Sweep/i-CMS）；
> > > 
> > >       类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间；
> > > 
> > >       但效果并不理想，**JDK1.6后就官方不再提倡用户使用**。
> > > 
> > > 更多请参考：
> > > 
> > >       官方的《垃圾收集调优指南》8.8节 Incremental Mode：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#CJAGIIEJ](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html%23CJAGIIEJ)
> > > 
> > >       《内存管理白皮书》 4.6.3节可以看到一些描述；

> > **（B）、无法处理浮动垃圾,可能出现"Concurrent Mode Failure"失败**

> > > **（1）、浮动垃圾（Floating Garbage）**
> > > 
> > > **      在并发清除时，用户线程新产生的垃圾**，称为浮动垃圾；
> > > 
> > >       这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；
> > > 
> > >       也要可以认为CMS所需要的空间比其他垃圾收集器大；
> > > 
> > >       "-XX:CMSInitiatingOccupancyFraction"：设置CMS预留内存空间；
> > > 
> > >       JDK1.5默认值为68%；
> > > 
> > >       JDK1.6变为大约92%；

> > > **（2）、"Concurrent Mode Failure"失败**
> > > 
> > >       如果CMS预留内存空间无法满足程序需要，就会出现一次"Concurrent Mode Failure"失败；
> > > 
> > >       这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生；
> > > 
> > >       这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大。

> > **（C）、产生大量内存碎片**
> > 
> >       由于**CMS基于"标记-清除"算法，清除后不进行压缩操作**；
> > 
> >       前面[《Java虚拟机垃圾回收(二) 垃圾回收算法》](http://blog.csdn.net/tjiyu/article/details/53983064)"标记-清除"算法介绍时曾说过：
> > 
> > > 产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。
> > 
> >       解决方法：                
> > 
> > > **（1）、"-XX:+UseCMSCompactAtFullCollection"**
> > > 
> > >       使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程；
> > > 
> > >       但合并整理过程无法并发，停顿时间会变长；
> > > 
> > >       默认开启（但不会进行，结合下面的CMSFullGCsBeforeCompaction）；
> > > 
> > > **（2）、"-XX:+CMSFullGCsBeforeCompaction"**
> > > 
> > >       设置执行多少次不压缩的Full GC后，来一次压缩整理；
> > > 
> > >       为减少合并整理过程的停顿时间；
> > > 
> > >       默认为0，也就是说每次都执行Full GC，不会进行压缩整理；

> > 由于空间不再连续，CMS需要使用可用"空闲列表"内存分配方式，这比简单实用"碰撞指针"分配内存消耗大；
> > 
> >       更多关于内存分配方式请参考：《[Java对象在Java虚拟机中的创建过程](http://blog.csdn.net/tjiyu/article/details/53923392)》
> 
> **      总体来看，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；**
> 
> **      但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间；**

> 更多CMS收集器信息请参考：
> 
>       《垃圾收集调优指南》 8节 Concurrent Mark Sweep (CMS) Collector：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html%23concurrent_mark_sweep_cms_collector)
> 
>       《内存管理白皮书》 4.6节 Concurrent Mark-Sweep (CMS) Collector：[http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

## **8、G1收集器**

> G1（**Garbage-First**）是**JDK7-u4**才推出商用的收集器；
> 
> **1、特点**

> > **（A）、并行与并发**
> > 
> >       能充分利用多CPU、多核环境下的硬件优势；
> > 
> >       可以并行来缩短"Stop The World"停顿时间；
> > 
> >       也可以并发让垃圾收集与用户程序同时进行；
> > 
> > **（B）、分代收集，收集范围包括新生代和老年代    **
> > 
> >       能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；
> > 
> >       能够采用不同方式处理不同时期的对象；
> > 
> >       虽然保留分代概念，但Java堆的内存布局有很大差别；
> > 
> >       将整个堆划分为多个大小相等的独立区域（Region）；
> > 
> >       新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合；
> > 
> >       更多G1内存布局信息请参考：
> > 
> > > 《垃圾收集调优指南》 9节：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html%23garbage_first_garbage_collection)

> > **（C）、结合多种垃圾收集算法，空间整合，不产生碎片**
> > 
> >       从整体看，是基于标记-整理算法；
> > 
> >       从局部（两个Region间）看，是基于复制算法；
> > 
> >       这是一种类似火车算法的实现；
> > 
> >       都不会产生内存碎片，有利于长时间运行；
> > 
> > **（D）、可预测的停顿：低停顿的同时实现高吞吐量**
> > 
> >       G1除了追求低停顿处，还能建立可预测的停顿时间模型；
> > 
> >       可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；

> **2、应用场景**
> 
>       面向服务端应用，针对具有大内存、多处理器的机器；
> 
>       最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；
> 
>       如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；
> 
>       用来替换掉JDK1.5中的CMS收集器；
> 
> **      在下面的情况时，使用G1可能比CMS好**：
> 
> > （1）、超过50％的Java堆被活动数据占用；
> > 
> >       （2）、对象分配频率或年代提升频率变化很大；
> > 
> >       （3）、GC停顿时间过长（长于0.5至1秒）。

> **      是否一定采用G1呢？也未必：**
> 
> > 如果现在采用的收集器没有出现问题，不用急着去选择G1；
> > 
> >       如果应用程序追求低停顿，可以尝试选择G1；
> > 
> >       是否代替CMS需要实际场景测试才知道。

> **3、设置参数**
> 
> **      "-XX:+UseG1GC"：指定使用G1收集器；**
> 
> **      "-XX:InitiatingHeapOccupancyPercent"：当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；**
> 
> **      "-XX:MaxGCPauseMillis"：为G1设置暂停时间目标，默认值为200毫秒；**
> 
> **      "-XX:G1HeapRegionSize"：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region；**
> 
>       更多关于G1参数设置请参考：
> 
> > 《垃圾收集调优指南》 10.5节：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#important_defaults](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html%23important_defaults)
> 
> **4、为什么G1收集器可以实现可预测的停顿**
> 
>       G1可以建立可预测的停顿时间模型，是因为：

> > 可以有计划地避免在Java堆的进行全区域的垃圾收集；
> > 
> >       G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表；
> > 
> >       每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）；
> > 
> >       这就保证了在有限的时间内可以获取尽可能高的收集效率；

> **5、一个对象被不同区域引用的问题**
> 
>       一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？
> 
>       在其他的分代收集器，也存在这样的问题（而G1更突出）：
> 
> > 回收新生代也不得不同时扫描老年代？
> 
>       这样的话会降低Minor GC的效率；
> 
> **      解决方法：**

> > 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：
> > 
> > > 每个Region都有一个对应的Remembered Set；
> > > 
> > >       每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；
> > > 
> > >       然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；
> > > 
> > >       如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
> > 
> > > 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；
> > > 
> > >       就可以保证不进行全局扫描，也不会有遗漏。

> **6、G1收集器运作过程**
> 
>       不计算维护Remembered Set的操作，可以分为4个步骤（与CMS较为相似）。

> > **（A）、初始标记（Initial Marking）**
> > 
> >       仅标记一下GC Roots能直接关联到的对象；
> > 
> >       且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象；
> > 
> >       需要"Stop The World"，但速度很快；
> > 
> > **（B）、并发标记（Concurrent Marking）**
> > 
> >       进行GC Roots Tracing的过程；
> > 
> >       刚才产生的集合中标记出存活对象；
> > 
> >       耗时较长，但应用程序也在运行；
> > 
> >       并不能保证可以标记出所有的存活对象；
> > 
> > **（C）、最终标记（Final Marking）**
> > 
> >       为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；
> > 
> >       上一阶段对象的变化记录在线程的Remembered Set Log；
> > 
> >       这里把Remembered Set Log合并到Remembered Set中；
> > 
> >       需要"Stop The World"，且停顿时间比初始标记稍长，但远比并发标记短；
> > 
> >       采用多线程并行执行来提升效率；
> > 
> > **（D）、筛选回收（Live Data Counting and Evacuation）**
> > 
> >       首先排序各个Region的回收价值和成本；
> > 
> >       然后根据用户期望的GC停顿时间来制定回收计划；
> > 
> >       最后按计划回收一些价值高的Region中垃圾对象；
> > 
> >       回收时采用"复制"算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存；
> > 
> >       可以并发进行，降低停顿时间，并增加吞吐量；

> **      G1收集器运行示意图如下：**

![](https://img-blog.csdn.net/20170102225017799)

> 更多G1收集器信息请参考：
> 
>       《垃圾收集调优指南》 9节 Garbage-First Garbage Collector：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html%23garbage_first_garbage_collection)
> 
>       《垃圾收集调优指南》 10节 Garbage-First Garbage Collector Tuning：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#g1_gc_tuning](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html%23g1_gc_tuning)

> **      到这里，我们大体了解HotSpot虚拟机中的所有垃圾收集器，后面我们将去了解JVM的一些内存分配与回收策略、JVM垃圾收集相关调优方法……**

## jvm 调优
## 堆大小设置

年轻代的设置很关键

JVM中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。

**典型设置：**

> java **-Xmx3550m -Xms3550m -Xmn2g** –Xss128k
> 
> **-Xmx3550m：**设置JVM最大可用内存为3550M。
> 
> **-Xms3550m：**设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
> 
> **-Xmn2g：**设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
> 
> **-Xss128k：**设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。

> java -Xmx3550m -Xms3550m -Xss128k **-XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0**
> 
> **-XX:NewRatio=4**:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
> 
> **-XX:SurvivorRatio=4**：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
> 
> **-XX:MaxPermSize=16m:**设置持久代大小为16m。
> 
> **-XX:MaxTenuringThreshold=0：**设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。

## 回收器选择

JVM给了三种选择：**串行收集器、并行收集器、并发收集器**，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前[系统配置](http://java.sun.com/j2se/1.5.0/docs/guide/vm/server-class.html)进行判断。

**吞吐量优先的并行收集器**

如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。

**典型配置：**

> java -Xmx3800m -Xms3800m -Xmn2g -Xss128k **-XX:+UseParallelGC -XX:ParallelGCThreads=20**
> 
> **-XX:+UseParallelGC：**选择垃圾收集器为并行收集器。**此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。**
> 
> **-XX:ParallelGCThreads=20：**配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。

> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 **-XX:+UseParallelOldGC**
> 
> **-XX:+UseParallelOldGC：**配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。

> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  **-XX:MaxGCPauseMillis=100**
> 
> **-XX:MaxGCPauseMillis=100**:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。

> n java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 **-XX:+UseAdaptiveSizePolicy**
> 
> **-XX:+UseAdaptiveSizePolicy**：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。

**响应时间优先的并发收集器**

如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。

**典型配置：**

> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 **-XX:+UseConcMarkSweepGC -XX:+UseParNewGC**
> 
> **-XX:+UseConcMarkSweepGC：**设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
> 
> **-XX:+UseParNewGC:** 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。

> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC **-XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection**
> 
> **-XX:CMSFullGCsBeforeCompaction：**由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
> 
> **-XX:+UseCMSCompactAtFullCollection：**打开对年老代的压缩。可能会影响性能，但是可以消除碎片

## 辅助信息

JVM提供了大量命令行参数，打印信息，供调试使用。主要有以下一些：

**-XX:+PrintGC：**输出形式：[GC 118250K->113543K(130112K), 0.0094143 secs] [Full GC 121376K->10414K(130112K), 0.0650971 secs]

**-XX:+PrintGCDetails：**输出形式：[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs]

**-XX:+PrintGCTimeStamps **-XX:+PrintGC：PrintGCTimeStamps可与上面两个混合使用
输出形式：11.851: [GC 98328K->93620K(130112K), 0.0082960 secs]

**-XX:+PrintGCApplicationConcurrentTime：**打印每次垃圾回收前，程序未中断的执行时间。可与上面混合使用。输出形式：Application time: 0.5291524 seconds

**-XX:+PrintGCApplicationStoppedTime：**打印垃圾回收期间程序暂停的时间。可与上面混合使用。输出形式：Total time for which application threads were stopped: 0.0468229 seconds

**-XX:PrintHeapAtGC: **打印GC前后的详细堆栈信息。输出形式：

34.702: [GC {Heap before gc invocations=7:

def new generation   total 55296K, used 52568K [0x1ebd0000, 0x227d0000, 0x227d0000)

eden space 49152K,  99% used [0x1ebd0000, 0x21bce430, 0x21bd0000)

from space 6144K,  55% used [0x221d0000, 0x22527e10, 0x227d0000)

to   space 6144K,   0% used [0x21bd0000, 0x21bd0000, 0x221d0000)

tenured generation   total 69632K, used 2696K [0x227d0000, 0x26bd0000, 0x26bd0000)

the space 69632K,   3% used [0x227d0000, 0x22a720f8, 0x22a72200, 0x26bd0000)

compacting perm gen  total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)

the space 8192K,  35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)

ro space 8192K,  66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)

rw space 12288K,  46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)

34.735: [DefNew: 52568K->3433K(55296K), 0.0072126 secs] 55264K->6615K(124928K)Heap after gc invocations=8:

def new generation   total 55296K, used 3433K [0x1ebd0000, 0x227d0000, 0x227d0000)

eden space 49152K,   0% used [0x1ebd0000, 0x1ebd0000, 0x21bd0000)

from space 6144K,  55% used [0x21bd0000, 0x21f2a5e8, 0x221d0000)

to   space 6144K,   0% used [0x221d0000, 0x221d0000, 0x227d0000)

tenured generation   total 69632K, used 3182K [0x227d0000, 0x26bd0000, 0x26bd0000)

the space 69632K,   4% used [0x227d0000, 0x22aeb958, 0x22aeba00, 0x26bd0000)

compacting perm gen  total 8192K, used 2898K [0x26bd0000, 0x273d0000, 0x2abd0000)

the space 8192K,  35% used [0x26bd0000, 0x26ea4ba8, 0x26ea4c00, 0x273d0000)

ro space 8192K,  66% used [0x2abd0000, 0x2b12bcc0, 0x2b12be00, 0x2b3d0000)

rw space 12288K,  46% used [0x2b3d0000, 0x2b972060, 0x2b972200, 0x2bfd0000)

}

, 0.0757599 secs]

**-Xloggc:filename:**与上面几个配合使用，把相关日志信息记录到文件以便分析。

## 常见配置汇总

**堆设置**

**-Xms:**初始堆大小

**-Xmx:**最大堆大小

**-XX:NewSize=n:**设置年轻代大小

**-XX:NewRatio=n:**设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4

**-XX:SurvivorRatio=n:**年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5

**-XX:MaxPermSize=n:**设置持久代大小

**收集器设置**

**-XX:+UseSerialGC:**设置串行收集器

**-XX:+UseParallelGC:**设置并行收集器

**-XX:+UseParalledlOldGC:**设置并行年老代收集器

**-XX:+UseConcMarkSweepGC:**设置并发收集器

**垃圾回收统计信息**

**-XX:+PrintGC**

**  -XX:+PrintGCDetails**

**  -XX:+PrintGCTimeStamps**

**  -Xloggc:filename**

**并行收集器设置**

**-XX:ParallelGCThreads=n**:设置并行收集器收集时使用的CPU数。并行收集线程数。

**-XX:MaxGCPauseMillis=n**:设置并行收集最大暂停时间

**-XX:GCTimeRatio=n**:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)

**并发收集器设置**

**-XX:+CMSIncrementalMode:**设置为增量模式。适用于单CPU情况。

**-XX:ParallelGCThreads=n:**设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。

## 调优总结

**年轻代大小选择**

**响应时间优先的应用：**尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。

**吞吐量优先的应用：**尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。

**年老代大小选择**

**响应时间优先的应用：**年老代使用并发收集器，所以其大小需要小心设置，一般要考虑**并发会话率**和**会话持续时间**等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：

1\. 并发垃圾收集信息

2\. 持久代并发收集次数

3\. 传统GC信息

4\. 花在年轻代和年老代回收上的时间比例

减少年轻代和年老代花费的时间，一般会提高应用的效率

**吞吐量优先的应用**

一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。

**较小堆引起的碎片问题**

因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：

1. **-XX:+UseCMSCompactAtFullCollection：**使用并发收集器时，开启对年老代的压缩。

2. **-XX:CMSFullGCsBeforeCompaction=0：**上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩

## jvm 命令
**javac**

```
用法: javac <options> <source files>
其中, 可能的选项包括:
 -g             生成所有调试信息
 -g:none          不生成任何调试信息
 -g:{lines,vars,source}   只生成某些调试信息
 -nowarn          不生成任何警告
 -verbose          输出有关编译器正在执行的操作的消息
 -deprecation        输出使用已过时的 API 的源位置
 -classpath <路径>      指定查找用户类文件和注释处理程序的位置
 -cp <路径>         指定查找用户类文件和注释处理程序的位置
 -sourcepath <路径>     指定查找输入源文件的位置
 -bootclasspath <路径>    覆盖引导类文件的位置
 -extdirs <目录>       覆盖所安装扩展的位置
 -endorseddirs <目录>    覆盖签名的标准路径的位置
 -proc:{none,only}     控制是否执行注释处理和/或编译。
 -processor <class1>[,<class2>,<class3>...] 要运行的注释处理程序的名称; 绕过默认的搜索进程
 -processorpath <路径>    指定查找注释处理程序的位置
 -d <目录>          指定放置生成的类文件的位置
 -s <目录>          指定放置生成的源文件的位置
 -implicit:{none,class}   指定是否为隐式引用文件生成类文件
 -encoding <编码>       指定源文件使用的字符编码
 -source <发行版>       提供与指定发行版的源兼容性
 -target <发行版>       生成特定 VM 版本的类文件
 -version          版本信息
 -help            输出标准选项的提要
 -A关键字[=值]        传递给注释处理程序的选项
 -X             输出非标准选项的提要
 -J<标记>           直接将 <标记> 传递给运行时系统
 -Werror           出现警告时终止编译
 @<文件名>          从文件读取选项和文件名
```
**java**

```
执行 .class文件，若类中没有main函数，则不能执行。

用法: java [-options] class [args...]
      (执行类)
  或 java [-options] -jar jarfile [args...]
      (执行 jar 文件)
其中选项包括:
  -d32     使用 32 位数据模型 (如果可用)
  -d64     使用 64 位数据模型 (如果可用)
  -server    选择 "server" VM
  -hotspot   是 "server" VM 的同义词 [已过时]
         默认 VM 是 server.

  -cp <目录和 zip/jar 文件的类搜索路径>
  -classpath <目录和 zip/jar 文件的类搜索路径>
         用 ; 分隔的目录, JAR 档案
         和 ZIP 档案列表, 用于搜索类文件。
  -D<name>=<value>
         设置系统属性
  -verbose[:class|gc|jni]
         启用详细输出
  -version   输出产品版本并退出
  -version:<value>
         需要指定的版本才能运行
  -showversion 输出产品版本并继续
  -jre-restrict-search | -no-jre-restrict-search
         在版本搜索中包括/排除用户专用 JRE
  -? -help   输出此帮助消息
  -X      输出非标准选项的帮助
  -ea[:<packagename>...|:<classname>]
  -enableassertions[:<packagename>...|:<classname>]
         按指定的粒度启用断言
  -da[:<packagename>...|:<classname>]
  -disableassertions[:<packagename>...|:<classname>]
         禁用具有指定粒度的断言
  -esa | -enablesystemassertions
         启用系统断言
  -dsa | -disablesystemassertions
         禁用系统断言
  -agentlib:<libname>[=<options>]
         加载本机代理库 <libname>, 例如 -agentlib:hprof
         另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help
  -agentpath:<pathname>[=<options>]
         按完整路径名加载本机代理库
  -javaagent:<jarpath>[=<options>]
         加载 Java 编程语言代理, 请参阅 java.lang.instrument
  -splash:<imagepath>
         使用指定的图像显示启动屏幕
```
**jar**

```
主要用于打包jar文件

用法: jar {ctxui}[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] files ...
选项包括:
  -c 创建新的归档文件
  -t 列出归档目录
  -x 从档案中提取指定的 (或所有) 文件
  -u 更新现有的归档文件
  -v 在标准输出中生成详细输出
  -f 指定归档文件名
  -m 包含指定清单文件中的清单信息
  -e 为捆绑到可执行 jar 文件的独立应用程序
    指定应用程序入口点
  -0 仅存储; 不使用情况任何 ZIP 压缩
  -M 不创建条目的清单文件
  -i 为指定的 jar 文件生成索引信息
  -C 更改为指定的目录并包含其中的文件
如果有任何目录文件, 则对其进行递归处理。
清单文件名, 归档文件名和入口点名称的指定顺序
与 'm', 'f' 和 'e' 标记的指定顺序相同。
```
**javap**

```
用法: javap <options> <classes>
其中, 可能的选项包括:
  -help  --help  -?        输出此用法消息
  -version                 版本信息
  -v  -verbose             输出附加信息
  -l                       输出行号和本地变量表
  -public                  仅显示公共类和成员
  -protected               显示受保护的/公共类和成员
  -package                 显示程序包/受保护的/公共类
                           和成员 (默认)
  -p  -private             显示所有类和成员
  -c                       对代码进行反汇编
  -s                       输出内部类型签名
  -sysinfo                 显示正在处理的类的
                           系统信息 (路径, 大小, 日期, MD5 散列)
  -constants               显示静态最终常量
  -classpath <path>        指定查找用户类文件的位置
  -bootclasspath <path>    覆盖引导类文件的位置
```
**jmap**
```
1）分析堆信息

jmap -heap java_pid

(2) 导出 java进程 5460 的堆内容 到文件 heap.map ,然后使用 jhat 分析

jmap -dump:live,file=heap.map 5460

jhat heap.map 

（3）打印等待回收的对象信息

jmap -finalizerinfo java_pid

(4) 打印永久区状态

jmap -permstat java_pid
```
**jinfo**

```
jinfo 打印指定java进程 、核心文件、远程服务的配置信息。配置信息包括Java系统属性和Java 虚拟机命令行参数；如果给定进程运行在64位机器上，你可能需要指定-J-d64 选项。

说明：这个功能在未来JDK中可能不可用或不被支持（java8 及 更高版本）

无选项 ：打印 命令行参数和java 系统属性键值对

-flag name 打印指定name 的命令行参数

-flag [+-]name 启用或禁用给定的命令行参数

-flag name=value 设定命令行参数到指定值

-flags 打印传递给虚拟机的命令参数

-sysprops 打印java 系统属性

-h 打印帮助信息

 在jdk1.7.0_09测试之后，仅 PermSize MaxPermSize 这两个参数支持 jinfo -flag name pid 输出

（1）打印参数值

$ jinfo -flag PermSize 5460
-XX:PermSize=268435456
（2）打印系统属性

jinfo -sysprops 5460
```
**jstat**

```
参考链接 docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html#class_option

(1)内存模型使用率及GC次数和用时/百分比

jstat -gcutil java_pid



S1使用率/S2使用率/初生代使用率/老年代使用率/永久区使用率/新生代GC次数/新生代GC用时s/FullGC次数/FullGC用时s/GC总共用时

 （2） 打印类装载信息

jstat -class java_pid

（3） 即时编译信息

jstat -compiler java_pid

（4）内存模型使用率及GC次数和用时/ kb



（5）VM中新生代 幸存代 初生代 年代永久区的最小空间 最大空间 以及当前空间

jstat -gccapacity java_pid | column -t



（6）新生代堆的用量

jstat -gcnew java_pid



（7）年轻代对象的信息及其占用量

jstat -gcnewcapacity <pid>

（8）old代对象的信息

jstat -gcold <pid>

（9）old代对象的信息及其占用量

jstat -gcoldcapacity <pid> 

（10）perm类的信息及其占用量

jstat -gcpermcapacity<pid>

（11）当前VM执行编译的信息

jstat -printcompilation <pid>
```
### Java定位CPU使用100%的方法
**1：Threaddump的方法：**

*   kill -3 pid
*   jstack -l pid
*   jvisualvm中来thread dump

**2：找到导致cpu高的线程**
top -H -p pid
  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                             
 4691 root      19   0  448m 132m  13m S  0.0  7.5   0:00.01 java                                                                
 4692 root      19   0  448m 132m  13m S  0.0  7.5   0:00.39 java                                                                
 4698 root      15   0  448m 132m  13m S  0.0  7.5   0:14.14 java                                                                
 4699 root      15   0  448m 132m  13m S  0.0  7.5   0:00.43 java                                                                
 4700 root      15   0  448m 132m  13m S  0.0  7.5   0:00.63 java                                                                
 4701 root      18   0  448m 132m  13m S  0.0  7.5   0:00.00 java                                                               

 对应的线程id是十进制的，需要转换为十六进制的在threaddump文件中才可以看到

**3：十进制转十六进制**
-bash-3.2# python
>>> print hex(4739)
0×1283

**4：找到对应的线程**
vi threaddump.log
查找：/0×1283
找到对应的线程，把相关的方法找出来，可以精确到代码的行号，自己修改相关源码来fix bug。
**cpu飙高，load高，响应很慢**

方案：
* 一个请求过程中多次dump

* 对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了。

**查找占用cpu最多的线程信息**

方案：
* 使用命令： top -H -p pid（pid为被测系统的进程号），找到导致cpu高的线程id。

上述Top命令找到的线程id，对应着dump thread信息中线程的nid，只不过一个是十进制，一个是十六进制。

* 在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息。

**cpu使用率不高但是响应很慢**

方案：
* 进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因。 

**请求无法响应**

方案：
* 多次dump，对比是否所有的runnable线程都一直在执行相同的方法，如果是的，恭喜你，锁住了！

【参考资料】

1、《编译原理》第二版 第7章

2、《深入理解Java虚拟机：JVM高级特性与最佳实践》第二版 第3章

3、《The Java Virtual Machine Specification》Java SE 8 Edition：[https://docs.oracle.com/javase/specs/jvms/se8/html/index.html](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)

4、《Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide》：[http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html)

5、《Memory Management in the Java HotSpot™ Virtual Machine》：[http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf](http://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf)

6、HotSpot虚拟机参数官方说明：[http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html](http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)

7、《Thinking in Java》第四版 5.5 清理：终结处理和垃圾回收；
8，[深入理解 Java G1 垃圾收集器](http://blog.jobbole.com/109170/) 
9，[https://blog.csdn.net/yano_nankai/article/details/50957578](https://blog.csdn.net/yano_nankai/article/details/50957578)
[https://www.zhihu.com/question/27339390](https://www.zhihu.com/question/27339390)
