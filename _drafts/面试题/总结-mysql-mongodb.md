面试-mysql
### **数据库**

**MySQL**

**为什么用自增列作为主键**

1.  如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。

2.  数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）

3.  如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

4.  如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

## **为什么使用数据索引能提高效率**

1.  数据索引的存储是有序的

2.  在有序的情况下，通过索引查询一个数据是无需遍历索引记录的

3.  极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)

## **B+树索引和哈希索引的区别**

B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

哈希索引的优势：

1.  等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）

哈希索引不适用的场景：

1.  不支持范围查询

2.  不支持索引完成排序

3.  不支持联合索引的最左前缀匹配规则

通常，B+树索引结构适用于绝大多数场景，像下面这种场景用哈希索引才更有优势：

在HEAP表中，如果存储的数据重复度很低（也就是说基数很大），对该列数据以等值查询为主，没有范围查询、没有排序的时候，特别适合采用哈希索引，例如这种SQL：

```
select id,name from table where name='李明'; — 仅等值查询
```

而常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。

注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。

## **B树和B+树的区别**

1.  B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。

    ![](https://mmbiz.qpic.cn/mmbiz/QCu849YTaIOqRD2H1iceraQdQroRXcW1YPNQD2iaD2ia5JniapuyYCvyAmfLwv9mjSDqM5yr0D8jo7MKnPxuH5yMsg/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1)

2.  B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

## **为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？**

1.  B+的磁盘读写代价更低 B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

2.  B+-tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## **MySQL联合索引**

1.  联合索引是两个或更多个列上的索引。对于联合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a   、    a,b   、  a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。

2.  利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引 不同于使用两个单独的索引。复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。如果您知 道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。

## **什么情况下应不建或少建索引**

1.  表记录太少

2.  经常插入、删除、修改的表

3.  数据重复且分布平均的表字段，假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。

4.  经常和主字段一块查询但主字段索引值比较多的表字段

## **MySQL分区**

### 一. 什么是表分区？

表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。

### 二. 表分区与分表的区别

分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。

分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。

### 三. 表分区有什么好处？

1.  分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。 2\. 和单个磁盘或者文件系统相比，可以存储更多数据

2.  优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。

3.  分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。

4.  可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。

### 四. 分区表的限制因素

1.  一个表最多只能有1024个分区

2.  MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。

3.  如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引列。

4.  分区表中无法使用外键约束

5.  MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。

### 五. 如何判断当前MySQL是否支持分区？

命令：show variables like '%partition%' 运行结果:

mysql> show variables like '%partition%'; +-------------------+-------+ | Variable_name     | Value | +-------------------+-------+ | have_partitioning | YES   | +-------------------+-------+ 1 row in set (0.00 sec) have_partintioning 的值为YES，表示支持分区。

### 六. MySQL支持的分区类型有哪些？

1.  RANGE分区： 这种模式允许将数据划分不同范围。例如可以将一个表通过年份划分成若干个分区

2.  LIST分区： 这种模式允许系统通过预定义的列表的值来对数据进行分割。按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。

3.  HASH分区 ：这中模式允许通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区。例如可以建立一个对表主键进行分区的表。

4.  KEY分区 ：上面Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的。

## **四种隔离级别**

1.  Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

2.  Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

3.  Read committed (读已提交)：可避免脏读的发生。

4.  Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

## **关于MVVC**

MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) (注：与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control)。MVCC最大的好处：读不加锁，读写不冲突。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，现阶段几乎所有的RDBMS，都支持了MVCC。

1.  LBCC：Lock-Based Concurrency Control，基于锁的并发控制。

2.  MVCC：Multi-Version Concurrency Control，基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提高了并发量。

在MVCC并发控制中，读操作可以分成两类：

1.  快照读 (snapshot read)：读取的是记录的可见版本 (有可能是历史版本)，不用加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写）。

2.  当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。

## **行级锁定的优点：**

1.  当在许多线程中访问不同的行时只存在少量锁定冲突。

2.  回滚时只有少量的更改

3.  可以长时间锁定单一的行。

## **行级锁定的缺点：**

1.  比页级或表级锁定占用更多的内存。

2.  当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。

3.  如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。

4.  用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。

## **MySQL触发器简单实例**

1.  CREATE TRIGGER <触发器名称>  --触发器必须有名字，最多64个字符，可能后面会附有分隔符.它和MySQL中其他对象的命名方式基本相象.

2.  { BEFORE | AFTER }  --触发器有执行的时间设置：可以设置为事件发生前或后。

3.  { INSERT | UPDATE | DELETE }  --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。

4.  ON <表名称>  --触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就导致触发器的激活. 我们不能给同一张表的同一个事件安排两个触发器。

5.  FOR EACH ROW  --触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。

6.  <触发器SQL语句>  --触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句， 包括复合语句，但是这里的语句受的限制和函数的一样。

## **什么是存储过程**

简单的说，就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法；

ps:存储过程跟触发器有点类似，都是一组SQL集，但是存储过程是主动调用的，且功能比触发器更加强大，触发器是某件事触发后自动调用；

有哪些特性

1.  有输入输出参数，可以声明变量，有if/else, case,while等控制语句，通过编写存储过程，可以实现复杂的逻辑功能；

2.  函数的普遍特性：模块化，封装，代码复用；

3.  速度快，只有首次执行需经过编译和优化步骤，后续被调用可以直接执行，省去以上步骤；

```
DROP PROCEDURE IF EXISTS `proc_adder`;DELIMITER ;;CREATE DEFINER=`root`@`localhost` PROCEDURE `proc_adder`(IN a int, IN b int, OUT sum int)BEGIN   #Routine body goes here...   DECLARE c int;   if a is null then set a = 0;    end if;    if b is null then set b = 0;   end if;   set sum  = a + b;END;;DELIMITER ;set @b=5;call proc_adder(0,@b,@s);SELECT @s as sum;create table tab2(  tab2_id varchar(11));DROP TRIGGER if EXISTS t_ai_on_tab1;create TRAILING t_ai_on_tab1AFTER INSERT ON tab1for EACH ROWBEGIN  INSERT INTO tab2(tab2_id) values(new.tab1_id);end;INSERT INTO tab1(tab1_id) values('0001');SELECT * FROM tab2;
```

## **MySQL优化**

1.  开启查询缓存，优化查询

2.  explain你的select查询，这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的

3.  当只要一行数据时使用limit 1，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据

4.  为搜索字段建索引

5.  使用 ENUM 而不是 VARCHAR，如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是VARCHAR。

6.  Prepared Statements Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击

7.  垂直分表

8.  选择正确的存储引擎

## **key和index的区别**

1.  key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等

2.  index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；

## **Mysql 中 MyISAM 和 InnoDB 的区别有哪些？**

区别：

1.  InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；

2.  InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；

3.  InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

4.  InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；

5.  Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；

如何选择：

1.  是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；

2.  如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB。

3.  系统奔溃后，MyISAM恢复起来更困难，能否接受；

4.  MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

## **数据库表创建注意事项**

### 一、字段名及字段配制合理性

1.  剔除关系不密切的字段

2.  字段命名要有规则及相对应的含义（不要一部分英文，一部分拼音，还有类似a.b.c这样不明含义的字段）

3.  字段命名尽量不要使用缩写（大多数缩写都不能明确字段含义）

4.  字段不要大小写混用（想要具有可读性，多个英文单词可使用下划线形式连接）

5.  字段名不要使用保留字或者关键字

6.  保持字段名和类型的一致性

7.  慎重选择数字类型

8.  给文本字段留足余量

### 二、系统特殊字段处理及建成后建议

1.  添加删除标记（例如操作人、删除时间）

2.  建立版本机制

### 三、表结构合理性配置

1.  多型字段的处理，就是表中是否存在字段能够分解成更小独立的几部分（例如：人可以分为男人和女人）

2.  多值字段的处理，可以将表分为三张表，这样使得检索和排序更加有调理，且保证数据的完整性！

### 四、其它建议

1.  对于大数据字段，独立表进行存储，以便影响性能（例如：简介字段）

2.  使用varchar类型代替char，因为varchar会动态分配长度，char指定长度是固定的。

3.  给表创建主键，对于没有主键的表，在查询和索引定义上有一定的影响。

4.  避免表字段运行为null，建议设置默认值（例如：int类型设置默认值为0）在索引查询上，效率立显！

5.  建立索引，最好建立在唯一和非空的字段上，建立太多的索引对后期插入、更新都存在一定的影响（考虑实际情况来创建）。

*   MySQL 索引使用的注意事项

*   DDL、DML、DCL分别指什么

*   explain命令

*   left join，right join，inner join

*   数据库事物ACID（原子性、一致性、隔离性、持久性）

*   事物的隔离级别（读未提交、读以提交、可重复读、可序列化读）

*   脏读、幻读、不可重复读

*   数据库的几大范式

*   数据库常见的命令

*   说说分库与分表设计

*   分库与分表带来的分布式困境与应对之策（如何解决分布式下的分库分表，全局表？）

*   说说 SQL 优化之道

*   MySQL遇到的死锁问题、如何排查与解决

*   存储引擎的 InnoDB与MyISAM区别，优缺点，使用场景

*   索引类别（B+树索引、全文索引、哈希索引）、索引的原理

*   什么是自适应哈希索引（AHI）

*   为什么要用 B+tree作为MySQL索引的数据结构

*   聚集索引与非聚集索引的区别

*   遇到过索引失效的情况没，什么时候可能会出现，如何解决

*   limit 20000 加载很慢怎么解决

*   如何选择合适的分布式主键方案

*   选择合适的数据存储方案

*   常见的几种分布式ID的设计方案
**数据库**

*   数据库索引，什么是全文索引，全文索引中的倒排索引是什么原理； 

*   数据库最佳左前缀原则是什么？ 

*   数据库的三大范式；

*   悲观锁和乐观锁的原理和应用场景； 

*   左连接、右连接、内连接、外连接、交叉连接、笛卡儿积等； 

*   一般情况下数据库宕机了如何进行恢复（什么是Write Ahead Log机制，什么是Double Write机制，什么是Check Point）； 

*   什么是redo日志、什么是undo日志； 

*   数据库中的隔离性是怎样实现的；原子性、一致性、持久性又是如何实现的； 

*   什么是组合索引，组合索引什么时候会失效； 

*   关系型数据库和非关系型数据库区别； 

*   数据库死锁如何解决； 

*   MySQL并发情况下怎么解决（通过事务、隔离级别、锁）； 

*   MySQL中的MVCC机制是什么意思，根据具体场景，MVCC是否有问题； 

*   MySQL数据库的隔离级别，以及如何解决幻读；
**数据库**

*   InnoDB的插入缓冲和两次写的概率和意义；

*   如果建了⼀个单列索引，查询的时候查出2列，会⽤到这个单列索引吗？（会用到）

*   如果建了⼀个包含多个列的索引，查询的时候只⽤了第⼀列，能不能⽤上这个索引？查三列呢？

*   接上题，如果where条件后⾯带有⼀个 i + 5 < 100 会使⽤到这个索引吗？

*   like %aaa%会使⽤索引吗? like aaa%呢?

*   drop、truncate、delete的区别？

*   平时你们是怎么监控数据库的? 慢SQL是怎么排查的？（慢查询日志）

*   你们数据库是否⽀持emoji表情，如果不⽀持，如何操作?选择什么编码方式？如果支持一个表情占几个字节?(utf8mb4)；

*   如果查询很慢，你会想到的第⼀个⽅式是什么？（数据库索引）
**数据库相关**

*   SQL优化思路，联合索引与底层树结构的映像关系，索引结构（B+、B-），为什么用这样的结构；

*   讲下MySQL的集群？集群遇到过什么问题？sql的优化？

*   你目前为止遇到的最大数据量是多少？知道100万时候怎么设计吗？1000万呢？过几十亿呢？

*   MySQL有多少个参数可调，除了最大连接数。全部列出来，一个个分析。

*   聊下优化过的索引，怎么优化;

*   红黑树和平衡树的区别，为什么数据库不用红黑树;

*   mysql有哪些锁，意向锁有什么用;

*   数据库高并发下的优化思路;

*   数据库什么情况下索引会失效;

*   常见的数据库优化方案，在你的项目中数据库如何进行优化的
===
# Mysql查询计划了解吗？如何使用的？
https://blog.csdn.net/wuseyukui/article/details/71512793
explain select 语句

# 你们的系统架构了解吗？主从不一致的情况你们怎么处理的？
系统架构必须了解啊，不光要了解，还要深入理解。
对于主从不一致的，对于一致性要求不强的场景，例如更新商品缓存等，我们是监听到商品变动的消息后，先睡眠3秒钟，然后更新缓存。
对于不容许主从不一致的场景，例如下单，支付，等需要验证的环节，直接是走主库的



SQL操作，主要是索引和聚合函数的应用
SQL语句编写
MySQL的几种优化
mysql行级锁
数据库锁表的相关处理

mysql
1，你们有用过分库分表吗，怎么实现的？
2，myism，innodb 他们的区别
3，联合索引什么情况下能走索引
4，hash 索引有用过吗，与b+tree 索引什么区别
BTree相关的操作

数据库索引的实现，B+树的结构和操作，为什么不用红黑树
SQL表设计 Join操作
数据库范式，聚集索引与非聚集索引
数据库存储过程，SQL注入

4.如何保证缓冲区和数据库之间的强一致性（使用加锁）
8.对于SQL慢查询的优化？（主要是从查询语句和数据库表设计两个方面来考虑，查询语句方面可以增加索引，增加查询筛选的限制条件；数据库表设计的时候可以拆分表，设计得更细粒度。但是后来才发现面试官想要的就是查询大量数据的慢查询问题的优化。。。）

Innodb的索引实现

innodb的锁有哪些？

事务的隔离级别是啥？有啥区别？隔离性分别是怎样的？

脏读、幻读、不可重复读是啥？

mysql数据引擎了解吗？有哪些区别？

如何分析sql用的是表锁还是行锁？
建索引需要注意什么？如何优化？

行列转换？
找出每个班级，每个科目前十的同学？

# 数据库应用方面踩过哪些坑？
# 数据库索引遇到过哪些问题？如何处理的？一般索引使用需要注意哪些内容？
# 除了explain，查看sql是否走索引有哪些方式？
# Mysql主从同步的原理了解吗？

# 数据库分库分表怎么做的？分片技术了解吗


# 数据库锁都有哪几类（gaps lock、Next-Key Lock了解吗），它们的原理是什么？锁与事务的关系了解吗？

# Mysql更新时哪些情况使用行锁，哪些情况使用表锁？如何对锁的使用情况进行具体的分析？


**6、连表查询方法、笛卡尔积通过什么连接得到 **sql对‘a’，‘b’，‘c’，‘d’排序，排成自己指定的顺序

答：连表查询方法，我大致说了三个，引入之前的答案：说句实在话，自从辞职读研以来很久没有用过sql语句了，关于这几个连接光靠记忆的话，完全会是懵逼，幸亏自己还不算蠢，很自然的根据字面理解，我很好的回答了出来，left join就是返回包括左表中所有记录和右表中联结字段相等的记录，好了面试官会问你，那么如果A表中，有甲丙丁3条记录，B表中有甲乙丙丁4条记录，那么如果条件都满足的情况，A left join B 丙记录是否会被查出，答案是否定的！好了，right join就是和left join 相反的，inner join等值联结 只返回2表中联结字段相等的行！讲到这里我就戛然而止，可能是面试官觉得我回答的还不够全面，所以又提醒我那么笛卡尔积怎么实现的，我想了想，突然脑子中冒出了个Cross join，于是脱口而出，交叉连接，然后面试官嗯了下，于是接着往下走问我一般用什么排序，我就回答，order by啦，然后就是提了下 desc 和ASC的含义，一个降序一个升序没什么好说的，最后话锋一转，问我，给我 a b c d 四个字符让我按照自定义的方式排序怎么实现，比如排序成 b a c d 我实话实说不知道。。。

数据库的acid是什么意思？什么是持久性？

数据库索引，b+树

mysql进行范围查询的时候，用的是B+树，准确查询使用的是hash

数据库建立索引需要考虑哪些因素

4、组合索引什么时候失效?
*   7、mysql数据库的引擎和区别是什么?
10、说说数据库设计的三范式，可以违反三范式吗？
3、mysql查询语句怎么做性能分析。
7、Mysql要加上nextkey锁，语句该怎么写

数据库索引为什么用b-树结构

**12、事务的隔离级别** 
  四种隔离级别，可能会出现哪些异常，mysql中默认级别。 
1.  数据流的锁级别，乐观锁和悲观锁的概念，是不是只有悲观锁？
2.  数据库如何实现事务？
3.  有没有什么研究深入的技术，或者比较满意的项目？

19。 数据库特性
ACID，顺便分别提了下实现原理

20.具体讲下隔离性。
四种隔离级别和实现方式

21.如何理解一致性？

说了下单个事务的一致性，以及分布式一致性。

22 一致性的三种级别
强，弱，最终一致性

23，持久性的实现方式

redo，同时使用insert buffer等方式。
## 8\. 数据库事务是什么，ACID表示什么

## 5\. 数据库隔离级别四种， 分别是什么

a. 什么是幻读，什么是不可重复读 
b. mysql默认级别，为什么

## 5.1 mysql和redis的区别，了解InnoDB吗

## 6\. 了解B树吗，数据库用哪种树，为什么不用另外一种

解释数据库范式，索引（不懂）。写了个查询语句：题目是从grade表中找出每科成绩都大于80分的学生名字。
怎么看慢查询日志
数据库怎么优化–我记了概念非得深入问
垂直拆分，水平拆分怎么做的等一系列

为什么数据库索引使用B+树
事务的四个特性
笛卡尔积通过什么连接得到sql（笛卡尔积的实现）
sql 的 left join，right join, inner join
数据库优化（索引和数据库结构优化）
sql注入，举例登录功能模块中sql注入的实现

Collection框架，List，Set，Map，Queue，ArrayList，LinkedList，HashMap，Vector，Hashtable，重点是HashMap的hash方法，put方法，get方法和resize方法。

ConcurrentHashMap和Collections.synchronizedMap的区别

谈谈volatile

ThreadLocal

代码模拟生产者消费者（使用ArrayBlockingQueue）

设计模式-单例模式

Java内存模型（内存划分）

JVM垃圾回收算法，比较各个算法的优劣

G1

Java内存泄漏问题

NIO

get和post，http状态码，http header
线程池

红黑树
MySQL的数据库引擎

对事务的理解

6、你平时数据库一般用的什么 mysql 那你说说在工作中一般用的什么数据库引擎 答 mysql默认的是InnoDB存储引擎 敢情面试官想给我使绊子来着，接着就让说InnoDB和MyISAM之间使用场景问题了，然后就就着这两种存储引擎的区别 以及 优缺点巴拉巴拉说了一通

7、平时是怎么处理事务的，讲下对事务的了解

8、看你简历上讲了分库分表 谈谈两个的使用 以及 在工作中 怎么去设计

这里主要是结合自己实习的项目来说的
2、sql注入了解么

8.怎么实现的分库分表？
4.数据库用的什么数据结构？底层存储怎么实现的？为什么要采用这种数据结构？tier树和B+树区别？


19.oracle和mysql的数据库隔离级别有什么不同？怎么避免幻读？

19.oracle和mysql的数据库隔离级别有什么不同？怎么避免幻读？

2.数据库索引

问了我索引的种类，特点以及怎样实现的，我提到了聚集非聚集以及B树红黑树，他详细问了红黑树，B树和二叉树区别。
4、数据库 sql 的了解程度。


5\. sql中replace和update的区别；

update是SQL中的数据更新命令，replace是VF中的数据更新命令；

update不需要打开表，repl命令需要先打开表；

update不加条件是更新表中所有记录，repl不加条件是更新当前记录，要加上all短语才是更新所有记录。

14.数据库四个范式的区别。在设计数据库的时候如何考量。

第一范式（1NF）属性不可拆分 或 无重复的列（保证列唯一）

第二范式（2NF）要求实体的属性完全依赖于主关键字。存在一个列被定义为唯一主键的表就是第二范式。（保证行唯一）

第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。（外键关系）

第四范式（4NF）禁止主键列和非主键列一对多关系不受约束用复合列做主键的表。

MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：

*   不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
*   不支持事务
*   不支持外键
*   不支持崩溃后的安全恢复
*   在表有读取查询的同时，支持往表中插入新纪录
*   支持BLOB和TEXT的前500个字符索引，支持全文索引
*   支持延迟更新索引，极大提升写入性能
*   对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

InnoDB

InnoDB在MySQL 5.5后成为默认索引，它的特点是：

*   支持行锁，采用MVCC来支持高并发
*   支持事务
*   支持外键
*   支持崩溃后的安全恢复
*   不支持全文索引
*   写一段 JDBC 连Oracle的程序,并实现数据查询
mysql数据库引擎及特点？
6\. SQL语句优化举例，核心

mysql索引原理？B+B-树？
5.数据库索引有什么作用?带来的问题是什么？
11\. 索引实现原理，索引的缺点以及是否占用存储空间

1、项目介绍，把项目的角色和用户的表结构画出来，这个表设计符合几范式？让你来改进这个表设计，你会怎么改？
数据库事务隔离级别


你知道索引使用的是哪种数据结构实现吗？

答到用的Hash表吧，答错。他又问，你知道为什么要使用树吗？答到因为Hash表可能会出现比较多的冲突，在千万甚至是上亿级别的数据面前，会大大增加查找的时间复杂度。而树比较稳定，基本保证最多二三十次就能找到想要的数据，对方说不完全对，最后我们还是交流了一下这个问题，我也明白了为什么要使用树，这里不说，网友朋友们觉得索引为什么要使用树来实现呢？
MySQL InnoDB存储的文件结构
索引树是如何维护的？
数据库自增主键可能的问题
*   什么是 ACID
## 数据库

MYSQL索引原理 
B+树和B-树
14、GMS
15、统计一天的订单量
16、IN HAVING  exsit


20、说一下缓存
21、统计所有重名用户
select name,count(*) from tab group by name having count(*)>1;

10、事务的控制
11、赃读
脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。
脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。
12、事务的传播属性
REQUIRED：业务方法需要在一个事务中运行。如果方法运行时，已经处在一个事务中，那么加入到该事务，否则为自己创建一个新的事务。(默认是这种事务行为)
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为它开启事务。如果方法在一个事务中（另一个bean）被调用，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行。
REQUIRESNEW：属性表明不管是否存在事务，业务方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务会被挂起，新的事务会被创建，直到方法执行结束，新事务才算结束，原先的事务才会恢复执行。
MANDATORY：该属性指定业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果业务方法在没有事务的环境下调用，容器就会抛出例外。

SUPPORTS：这一事务属性表明，如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分。如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行。
Never：指定业务方法绝对不能在事务范围内执行。如果业务方法在某个事务中执行，容器会抛出例外，只有业务方法没有关联到任何事务，才能正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按REQUIRED属性执行.它使用了一个单独的事务， 这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效

数据库系统提供了四种事务隔离级
(两个或者多外并发事务当中)
脏读：一个事务读取到另一事务未提交的更新新据。
不可重复读：在同一事务中，多次读取同一数据返回的结果有所不同。换句话说就是，后续读取可以读到另一事务已提交的更新数据。相反，“可重复读”在同一事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另一事务已提交的更新数据。
幻读：一个事务读取到另一事务已提交的insert数据


*   讲讲你平常是如何针对具体的SQL做优化； 

*   mysql的存储引擎有哪些，区别； 

8、数据库垂直和水平拆分

5、开发中用了那些数据库？回答mysql，储存引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。
**4\. 实践中如何优化MySQL**

我当时是按以下四条依次回答的，他们四条从效果上第一条影响最大，后面越来越小。

① SQL语句及索引的优化

② 数据库表结构的优化

③ 系统配置的优化

④ 硬件的优化

**5\. SQL语句的优化**

order by要怎么处理

alter尽量将多次合并为一次

insert和delete也需要合并

**6\. 索引的底层实现原理和优化**

B+树，经过优化的B+树
MySQL，b-树，b+树
4、怎样防止SQL注入

5、什么情况下索引失效

四、Mysql

1、事务的隔离级别？

2、Mysql 默认是哪个？

3、会发生幻读吗？

4、间隙锁给我解释一下

5、InnoDB引擎和MyISAM的区别？

6、为什么count(*) 会MyISAM 效果要好。 MYISAM 内部怎么实现的。

7、MVCC了解吗？ 说一下怎么实现的。

8、说说聚簇索引

9、说说二级索引是什么

10、那使用二级索引的时候是按二级索引来，还是按聚簇来（这个没听明白）
2、讲一下数据的acid

3、什么是一致性

4、什么是隔离性

5、Mysql的隔离级别

6、每个隔离级别是如何解决
6、数据库设计中常讲的三范式是指什么？
1.数据库表设计：一个公司生产产品，每个产品由很多配件组成，配件由厂商生产，根据此设计数据库表 
5.数据库的优化语句，如何实现查询效率尽可能高（索引） 

查看 SQL 是不是使用了索引？（有什么工具）
**5、开发中用了那些数据库？回答mysql，储存引擎有哪些？然后问了我悲观锁和乐观锁问题使用场景、分布式集群实现的原理。**

### 数据存储

*   MySQL 索引使用的注意事项

*   说说反模式设计

*   说说分库与分表设计

*   分库与分表带来的分布式困境与应对之策

*   说说 SQL 优化之道

*   MySQL 遇到的死锁问题

*   存储引擎的 InnoDB 与 MyISAM

*   数据库索引的原理

*   为什么要用 B-tree

*   聚集索引与非聚集索引的区别

*   limit 20000 加载很慢怎么解决

*   选择合适的分布式主键方案

*   选择合适的数据存储方案

*   ObjectId 规则

*   聊聊 MongoDB 使用场景

*   倒排索引

*   聊聊 ElasticSearch 使用场景
51\. 读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式

59\. sql语句各种条件的执行顺序，如select， where， order by， group by

60\. select  xx from xx where xx and xx order by xx limit xx； 如何优化这个（看explain）
求表的size，或做数据统计可用什么存储引擎

81\. 读多写少可用什么引擎

82\. 假如要统计多个表应该用什么引擎
102\. innodb对一行数据的读会枷锁吗？不枷锁，读实际读的是副本
10.给你一个表只有一列name~~有重复的name, 然后求出前十个name数最大的：

select name,count(name) from table group by name desc limit 10

1
6、 SQL 注入遇到过吗？怎么解决？
int(8) 和 int(10) 的区别是什么
Mysql和mongodb索引原理，MongoDB为什么使用B-树而不是B+树
有1万个左右的脏词，每次发帖要判断帖子里边是否包括有脏词，数据库应该如何设计

可以建立一个脏词字典表，写好函数判断帖子正文里面是否有脏词。然后再这个帖子正文字段上面建立check 约束。

MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：

*   不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
*   不支持事务
*   不支持外键
*   不支持崩溃后的安全恢复
*   在表有读取查询的同时，支持往表中插入新纪录
*   支持BLOB和TEXT的前500个字符索引，支持全文索引
*   支持延迟更新索引，极大提升写入性能
*   对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

InnoDB

InnoDB在MySQL 5.5后成为默认索引，它的特点是：

*   支持行锁，采用MVCC来支持高并发
*   支持事务
*   支持外键
*   支持崩溃后的安全恢复
*   不支持全文索引

14.数据库四个范式的区别。在设计数据库的时候如何考量。

第一范式（1NF）属性不可拆分 或 无重复的列（保证列唯一）

第二范式（2NF）要求实体的属性完全依赖于主关键字。存在一个列被定义为唯一主键的表就是第二范式。（保证行唯一）

第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。（外键关系）

第四范式（4NF）禁止主键列和非主键列一对多关系不受约束用复合列做主键的表。
MySQL InnoDB存储的文件结构

索引树是如何维护的？

数据库自增主键可能的问题



、写一个sql语句，查询一张表中，发表批评最多的人
