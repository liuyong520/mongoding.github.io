面试-java 虚拟机
===
### **JVM**

*   JVM运行时内存区域划分

*   内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决

*   如何判断对象是否可以回收或存活

*   常见的GC回收算法及其含义

*   常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等

*   JVM如何设置参数

*   JVM性能调优

*   类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的

*   类加载的过程：加载、验证、准备、解析、初始化

*   强引用、软引用、弱引用、虚引用

*   Java内存模型JMM
*   JMM里边的原子性、可见性、有序性是如何体现出来的，JMM中内存屏障是什么意思，
*   引用计数法与GC Root可达性分析法区别； 
**JVM**

*   Minor GC与Full GC分别在什么时候发生？什么时候触发Full GC; 

*   GC收集器有哪些？CMS收集器与G1收集器的特点。 

*   Java在什么时候会出现内存泄漏； 

*   Java中的大对象如何进行存储； 

*   rt.jar被什么类加载器加载，什么时间加载； 

*   自己写的类被什么加载，什么时间加载；

*   自己写的两个不同的类是被同一个类加载器加载的吗？为什么？

*   为什么新生代内存需要有两个Survivor区？

*   几种常用的内存调试工具：jmap、jstack、jconsole；

*   类加载的五个过程：加载、验证、准备、解析、初始化；

*   G1停顿吗，CMS回收步骤，CMS为什么会停顿，停顿时间；

*   栈主要存的数据是什么，堆呢？ 

*   堆分为哪几块，比如说新生代老生代，那么新生代又分为什么？ 

*   软引用和弱引用的使用场景（软引用可以实现缓存，弱引用可以用来在回调函数中防止内存泄露）；

*   为什么JVM调优经常会将-Xms和-Xmx参数设置成一样；
*   Java内存模型，方法区存什么；

*   CMS垃圾回收过程；

*   Full GC次数太多了，如何优化；
*   如果你的项目出现了内存泄露，怎么监控这个问题呢；
*   标记清除和标记整理的区别和优缺点，为何标记整理会发生stop the world；
*   什么情况下会触发类加载；
*   涉及OOM、JVM优化、源码问题、数据库优化、多线程等问题;

*   CPU高？什么情况CPU高？解决什么问题？
*   我看你做过性能优化，比如你怎么分析项目里面的OOM的，内存泄露呢？详细说思路;

*   逃逸分析是什么，作用是什么，用途是什么;

*   讲下JVM的大页模式，JVM内存模型;
*   对象内存布局，然后讲下对象的死亡过程？

*   对象头，详细讲下；

JVM回收机制，从判断对象死亡、GC Roots、Stop the World、回收算法优缺点讲起，提到引用计数弊端。

JVM中给对象赋值为null，一定会被回收么？举个case，讲到了内存泄露。
JVM的回收算法，当我背到一半后，打断了，说我知道你是为了面试背背而已，过几天忘了

major gc和full gc的区别，我脑抽，说反了，被鄙视了

聊了这么久虚拟机，你调过优吗？怎么调的。。。一脸懵逼


9.Java内存泄露的问题调查定位：jmap，jstack的使用等等
（1）Java虚拟机的内存布局

（2）GC算法及几种垃圾收集器

（3）类加载机制，也就是双亲委派模型

（4）Java内存模型

（5）happens-before规则

（6）volatile关键字使用规则


**4）Java的虚拟机的内容。这部分主要包括三部分，GC、类加载机制，以及内存。**

一个**GC部分简单的连环炮。**

**面试官可以先问你什么时候一个对象会被GC？**

接着继续问你为什么要在这种时候对象才会被GC？

接着继续问你GC策略都有哪些分类？

你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？

你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？

你如果选出来了，继续问你，为什么要选择这个策略？

**下面是关于类加载机制的简单连环炮。**

**首先肯定是先问你Java的类加载器都有哪些？**

回答了这些以后，可能会问你每个类加载器都加载哪些类？

说完以后，可能会问你这些类加载之间的父子关系是怎样的？

你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？

你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？

你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？

**再来一个关于内存的连环炮。**

**首先肯定就是问你内存分为哪几部分，这些部分分别都存储哪些数据？**

然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？

接着可能会问你，内存的哪些部分会参与GC的回收？

完事以后，可能还会问你Java的内存模型是怎么设计的？

你回答了以后，还会继续问你为什么要这么设计？

问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？

你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。

7，你知道哪些java 命令
- jps
- jstack
- jmap
- jinfo


8，无锁化，了解吗？
- java 编译器的优化，会有锁消除的优化
- 基于cas 原子语义的无锁化，循环cas 实现无锁

1，对于一个拥有千人访问的内部系统，有一天运用反馈系统非常卡，身为系统负责人的你该干些什么，问题可能出在哪，你会用什么工具或方法定位排查问题？
# CPU占用率非常高，如何查看具体是哪段代码引起的？
处理思想是先获取占用cpu 最高的进程pid（可以用top 命令），然后获取该进程内占用cpu 最高的线程tid（可以用 top -Hp或ps -mp 命令），然后获取线程栈信息（用jstack命令），把tid 转成16进制，从线程栈中查找该线程信息分析
### 延深：系统响应缓慢，怎么排查？
系统响应缓慢，多是有线程长期占用cpu，或频繁gc，可以对比多次获取的线程栈信息，如果某线程长时间运行，问题多处于此处。
某天下午，突然接到运营反馈，官网后台系统非常缓慢，通过上述操作，发现某个业务线程一直在运行，然后早到了这个请求，最后发现是有人操作了导出excel表格，但此处没有选择日期等时间，导致数据量相当的大，然后gc 频繁，所以整个系统变慢，
最近


# 内存泄漏问题具体如何排查？
长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景。具体主要有如下几大类：
- 静态集合类引起内存泄漏
- 各种连接，比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的
-单例模式
排查方式：
- 线上分析，用jmap查看存活的对象情况（jmap -histo:live [pid]）
写btrace脚本
-离线分析，获取堆转储快照，jmap - dump，通过工具分享推转储快照

JVM内存查看与分析，编写内存泄露实例
线上CPU100%，如何定位和排查问题
如何在运行时确定对象类型？

3.说说深入理解JVM中印象最深刻的章节（我说了JVM内存模型，垃圾回收和类加载）；
JVM内存结构

jvm类加载机制是什么？


JVM垃圾回收机制，何时触发MinorGC等操作
新生代和老生代的内存回收策略
Eden和Survivor的比例分配等
18、JVM的内存管理，
19、堆内存、栈内存溢出


*   简述synchronized?Object；Monitor机制；

*   简述happen-before规则； 

*   JUC和Object；Monitor机制区别是什么；简述AQS原理； 

*   简述DCL失效原因，解决方法； 


*   jvm运行时数据区域有哪几部分组成，各自作用； 

*   gc算法有哪些；gc收集器有哪些； 


*   简述class加载各阶段过程；class；loader有哪些模型； 

*   简述常用的JDK命令行工具； 

*   简述字节码文件组成； 


*   gc:内存模型； 

*   gc:垃圾回收； 


7、JVM内存模型

JVM内存分代，
Java 8的内存分代改进
深入分析了Classloader，双亲委派机制

JVM的编译优化
对Java内存模型的理解，以及其在并发中的应用
指令重排序，内存栅栏等

3、对JVM熟不熟悉？简单说说类加载过程，里面执行的哪些操作?问了GC和内存管理，平时在tomect里面有没有进行过相关的配置
1、说说什么时候触发垃圾回收。

2、虚拟机内存是怎么分配的？

3、各个内存区域能发生内存溢出的有哪些？

4、内存溢出和内存泄漏的区别？

5、堆为了垃圾回收怎么划分？

6、说说各个分带的垃圾回收策略。

7、怎么判断一个对象无用，需要回收。

8、G1垃圾回收器有什么优点。

9、其他垃圾回收器有哪些？了解吗？

10、虚拟机会把直接内存锁住吗？ ，操作系统会不会给他收走？

11、通过JNI调用底端c代码划一块内存这块内存属于虚拟机管理范畴吗？
类加载过程，如何获得当前对象的ClassLoader


JVM对final关键字的编译优化
补充：还问了堆和栈中存的是什么？static修饰的遍历存在哪里？（方法区）
jvm了解吗？内存模型和GC原理都是啥？
堆怎么管理的？如何分配、回收对象的？
# JVM的垃圾回收机制了解吗？
# 类加载的详细过程了解吗？常见的类加载器有哪些？

什么情况下会触发Minor GC 
使用过什么垃圾收集器，Serial收集器有什么特点 


GC。复制清除等几种算法


2、什么时候触发Full GC?
9、什么是GC，其优点和原理是什么?
10、Java如何进行垃圾回收
 5、Fullgc会导致什么问题?
23.堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)；
20.Jvm和Gc机制；
8、Java的内存模型，垃圾回收
2、JVM老年代和新生代的比例？

3、YGC和FGC发生的具体场景

4、jstack，jmap，jutil分别的意义？如何线上排查JVM的相关问题？

**4、JVM内存管理，GC算法，HotSpot里面的垃圾回收器、类加载** 
  JVM内存主要分为五个区，哪些是线程共享的，哪些是线程独享的，每个区存放什么。GC方面：怎么判断哪些对象需要被GC，GC的方法，Minor GC与Full GC。HotSpot GC算法以及7种垃圾回收期，主要讲了CMS和G1收集器。类加载：类加载的过程，Bootstrap classloader-ExtClassloader-AppClassloader，父类委托机制。


8.  jvm的垃圾回收分为哪些种类？每一种都是怎么去实现的？讲述一下G1的回收策略？
9.  jvm中的参数分为哪些种类，都是做什么的？jvm的监控怎么做？实际项目上线以后的监控怎么做？
10.  JVM中，如果把堆内存参数配置的超过了本地内存，会怎么样？
11.  JVM中的内存结构分为哪些方面？
12.  栈空间是怎么样的？每个线程只有一个栈吗？
13.  栈空间的内部结构是怎么样的？
14.  堆内存为什么要设计为分代？

2.Minor GC和Full GC的触发时机
JVM垃圾回收、数据区域、内存模型

1、java中会存在内存泄漏吗，请简单描述。

会。如：int i,i2; return (i-i2); //when i为足够大的正数,i2为足够大的负数。结果会造成溢位，导致错误。
4、Java的虚拟机JVM的两个内存：栈内存和对内存的区别是什么？
*   简单说说你了解的类加载器。是否实现过类加载器

具体解释了volatile禁止指令排序机制和对象new过程。

6.  双亲委派模型是什么

OOM你遇到过哪些情况？你是怎么搞定的？
5.讲下堆的作用。

6.堆的垃圾回收对象选择原则。

所谓根集就量正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃 圾收集首选需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根 集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。下面介绍几个常用的算法。


7、问了下java内存模型 讲了下垃圾回收算法

又是一通巴拉巴拉 比较了各个算法的优劣和问题之类的。。。再问G1，幸亏一面后来去看了下，于是说了下大概的认知。。。

8、Java内存泄露的问题




4.jvm内存模型？老年代使用哪种垃圾收集算法
9.jvm为什么要指令重排？jvm都有哪些性能优化措施？jit编译器的原理？
12、谈谈java的垃圾回收机制

从java提供垃圾回收机制说起，谈到了回收时机 何时回收 以及几个常用的垃圾回收算法，然后面试官问了解G1吗，听过但没具体了解了，实话实说，就没再继续了。。
问：是否有线上调试经验

答：老实回答没有(囧)
上来问了JVM调优的几个参数，新生代老年代等问题，没搞过一下子就慌了神，以至于后面的问题答的稀烂。

问：CMS收集器所基于的垃圾收集算法

答：标记-整理(实际是标记-清除算法，会带来内存碎片)

## 11\. JVM的内存模型

## 12\. JVM的GC算法

## 13\. JVM的GC器
4、线上服务 CPU 很高该怎么做？有哪些措施可以找到问题

**3、对JVM熟不熟悉？简单说说类加载过程，里面执行的哪些操作?问了GC和内存管理，平时在tomcat里面有没有进行过相关的配置**
**7、****JVM内存模型**
**2、****JVM老年代和新生代的比例？** **3、****YGC和FGC发生的具体场景** **4、****jstack，jmap，jutil分别的意义？如何线上排查JVM的相关问题？** **5**

41\. 如何手动触发全量回收垃圾，如何立即触发垃圾回收
56\. 何时会内存泄漏，内存泄漏会抛哪些异常

74\. 静态内部类加载到了哪个区？方法区

75\. class文件编译后加载到了哪
5、减少GC开销的措施：

1.  不要显示的调用System.gc（）
2.  尽量减少临时对象的使用
3.  对象不用的时候最好显示置空
4.  尽量使用StringBuffer，不实用String累加字符串（String的特性有关）
5.  能使用基本数据类型就不要使用封装类
6.  尽量减少静态对象变量的使用

21.如何解决Java GC 导致的延迟问题.

设置gc的算法，优化程序，使用分布式jvm等等方法吧

29.minor GC和Full GC的触发时机

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法去空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小


什么情况会栈溢出

（1）可能是由于循环的递归引起的。无限递归

（2）由于分配了过大的局部变量引起。
4.类加载主要步骤

*   加载 把 class 文件的二进制字节流加载到 jvm 里面
*   验证 确保 class 文件的字节流包含的信息符合当前 jvm 的要求 有文件格式验证, 元数据验证, 字节码验证, 符号引用验证等
*   准备 正式为类变量分配内存并设置类变量初始值的阶段, 初始化为各数据类型的零值
*   解析 把常量值内的符号引用替换为直接引用的过程
*   初始化 执行类构造器<clinit>()方法
*   使用 根据相应的业务逻辑代码使用该类
*   卸载 类从方法区移除

10.new 实例化过程

寻找类定义 ；

加载类定义，jvm启动时，会用启动类加载器加载，对于用户的class，则会用应用程序类加载器实时加载，所谓实时加载，指的是遇到的时候再加载，而不是预先一次 性加载。关于类加载器，有三级，jvm严格的限制了每一级的加载权限，加载模式为“双亲委托模式”，加载任何类，都先由父加载器加载。

给对象分配内存空间；jvm在内存“堆”中，开辟一个空间，该空间按照MyObject类定义开辟，并将该空间中的各个内存段设置默认值，对应的就是对象的属性初始化默认值。 

对象的初始化顺序 ；给父类静态变量默认值，对父类静态变量赋值，执行父类静态块；给当前类静态变量默认值 ，对当前类静态变量赋值，执行当前类静态块；给父类变量默认值，对父类变量赋值， 执行父类构造函数；给当前类变量默认值，对当前类变量赋值，执行当前类构造函数。

对象构造完成 ；
4.如何判断一个对象已经被回收

2、gc的概念，如果A和B对象循环引用，是否可以被GC？ 
这个循环引用是否被回收，就看这个循环引用是否挂在根上，A引用B，B引用A，A和Ｂ并没有挂在某个内存元和根上，当他们的生命周期结束的时候。这两个对象都有可能被回收。
3、Java中的内存溢出是如何造成的 
OutOfMemoryError： 
1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 
2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 
3.代码中存在死循环或循环产生过多重复的对象实体； 
4.使用的第三方软件中的BUG； 
5.启动参数内存值设定的过小；

Java 8的内存分代改进
JVM的编译优化
1、Java中的内存溢出是如何造成的

2、gc的概念，如果A和B对象循环引用，是否可以被GC？
垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。
1.简单的懒汉式在多线程环境下不是线程安全的。有人提出在getInstance()方法上同步锁，但是锁住一整个方法可能粒度过大，不利于效率。
单例模式的饿汉式，在定义自身类型的成员变量时就将其实例化，使得在Singleton单例类被系统（姑且这么说）加载时就已经被实例化出一个单例对象，从而一劳永逸地避免了线程安全的问题。

