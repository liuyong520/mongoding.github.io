面试-dubbo
===

****Dubbo****

*   什么是Dubbo，可参考《[Dubbo入门](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483791&idx=1&sn=49345f1a022734e81e9257f2b8d38a52&chksm=e9c5f83edeb2712805a77c1e1589e8f1d04bd17e55eeb2a45cabddb46d03615636908f058628&scene=21#wechat_redirect)》

*   什么是RPC、如何实现RPC、RPC 的实现原理，可参考《[基于HTTP的RPC实现](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483900&idx=1&sn=c5ca198a66a701f81c2ab118fe7a734a&chksm=e9c5f84ddeb2715bc574e467cd6537ef81f223453e0989ffd136976b48dcc2d961a75be596de&scene=21#wechat_redirect)》

*   Dubbo中的SPI是什么概念

*   Dubbo的基本原理、执行流程

*   Dubbo请求流程以及原理；

dubbo：
1，dubbo group、version 你们是怎么运用的？
对于group的使用我们有两种，第一种：提供方部署多个集群，不同的调用方调用不同的集群，避免非核心业务压垮提供方，影响到核心调用方
第二种：对于部分相同接口提供两种不同的实现，一种带缓存，一种不带缓存，通过设置group：direct/cache  ,让调用方决定调用哪个接口。
对于version 的运用多是存在不兼容的接口升级，通过灰度发布的方式，某一阶段同时存在新老两个版本的接口部署，逐步过渡到最新的接口
我们在开发环境也常用version，在联调阶段，本地调试，为了让调用方调到提供方指定的机器，双方约定用相同的版本号。

2，dubbo 超时，你们是怎么配置 的，默认的是多少？
我们的dubbo 接口通常都很快，从监控上看，大多数是个位数的毫秒级平均值。
我们的超时时间取的是比99分位响应时间大的数字，比如商品api 超时时间是500，
由于商品api 是最基础的api，促销api、价格api 都是在商品api之上的api，他们设置超时时间不仅要参考99分位值，还要参考商品api 的响应时间，所以他们的api 的响应时间比商品api 的长，目前促销价格api 的响应时间是800ms，说到这还要说下redis ，mysql 的超时时间，由于dubbo 的超时时间设置的是500，所以redis 和mysql的超时时间设置的比500 大就没有什么意义了，所以在api 层面我们的redis ，mysql的超时时间是比dubbo 接口的超时时间短的。对了，我们的超时时间是配在接口提供方的。

3，dubbo 重试你们用过吗，什么时候会触发重试？
当然有在用了，因为有超时时间的限制，设置超时时间是出于避免线程都被慢事务耗尽，从而引起雪崩效应的，超时时间我们是参照99分位设置的，那肯定会存在偶尔超时的现象，通过允许重试是可以减少请求错误的，通常设置重试我们肯定首先考虑接口的幂等性的，对于非幂等的接口我们是不允许重试的，对于幂等接口我们只允许重试一次，避免在极端情况下加剧恶化整个集群，对于重试的设置，我们也是定义在提供方的。我从源码中看到的对于rpcException 包装的非业务异常，都支持重试。

4，运用dubbo 你们是怎么处理分布式事务的？
对于分布式事务，业界有很多的处理方案和理论，有追求强一致性的2pc，3pc 等方案，也有最近比较火热的类似于2pc 思想的基于业务层的tcc 方案，当然更多的声音是追求最终一致性。我们采用最多的是一致性的方案，对于不同的场景我们有不同的处理方式，例如商品详情页的缓存，我们商品修改，先写库，然后通过rabbitmq 发消息，然后我们有系统监听消息，去把redis 的相应缓存删掉。在缓存删除之前是会存在不一致的，不过这种不一致是可接受的，消息处理后，缓存里的数据和数据库里的就是一致 的了。在例如订单，及状态等的同步，对于这些不容许出错的地方，我们有一套严格的机制，是结合着数据库，mq，定时任务按照最少一次的原则发的消息，加上消费方消息手动确认，以及去重机制，来保证消息的可靠性，从而解决了分布式事务，实现了最终一致性的。具体方案如下：业务处理完之后，发送消息，在事务中是把消息入库的，收集消息的交换器，routkey，消息体，和业务处理在同一个事务中，保证消息落盘，然后异步的把消息发出去，把消息删除掉，这这个环节中存在事务问题，有可能发了消息，消息没删除，我们还有个定时任务定时把数据库中的未删除的消息进行补发，这样是有可能产生重复消息的，我们要的就是最少发一次，一但消息发送出去，rabbitmq 自身也有保证消息的可靠性，在接收方，处理消息是手动ack 处理的，同时还要做去重处理，因为最少发一次，是有可能有重复消息，所以发送方法的每条消息都有个uuid，接收方把uuid 写到nosql，方便去重查询处理。
当然这种实现起来比较复杂，我们不是所有的都是这样处理的，有部分不是很重要的，我再代码中自己实现的有重试，重试多次也失败，那就记下日志，或发出警告，通过后续的人工补偿去处理。


5，运用dubbo 你们是怎么定义接口的
我们着重考虑了入参和返回值，还有考虑了接口的幂等下，尽量往幂等上考虑，
入参有两个公参，source：来源，调用方，plantform：端，app、pc，wap，小程序
返回值：apiResponseBody，里面有数据域，错误枚举等。
6，dubbo 是怎么处理一次请求的返回的？
dubbo 自己实现了一套类似jdk 线程池异步调用的机制get（）时检查结果有没有返回回来，没有则等待

# 服务的兼容控制你们是如何做的？
对于dubbo服务有以下两种
1，通过version 版本控制，线上同上部署两个版本的接口
2，新提供一个接口，让调用方逐步迁到新接口
对于给app 客户端提供的服务接口有以下几种：
1，在url 中加v版本号，系统中可能存在多个版本的接口
2，在公参中带版本号，服务端通过版本号，做兼容控制

# 你们是如何发布线上服务的？切流量操作怎么做的？

1，对于dubbo服务，部分部分的启动
2，对于tomcat 服务，先是从nginx 摘除ip，然后启动，重新挂到nginx 上，然后把剩余的摘除，启动挂上。

1、Dubbo超时重试；Dubbo超时时间设置
2、如何保障请求执行顺序

Dubbo底层实现，Dubbo相比webservice等方式的优势
设计模式，服务治理等


1.了解SOA，微服务吗？
2.分布式系统如何负载均衡？如何确定访问的资源在哪个服务器上？

一.轮询。二.随机。三.最小响应时间。四. 最小并发数。五.哈希。
3.设计一个分布式负载均衡缓冲系统，如何快速定位到是那个服务器（使用key分段、一致性hash）
11，dubbo 泛化调用？
dubbo架构了解吗？

# Dubbo的多播注册知道吗？原理是什么？

# Dubbo一次调用的详细过程了解吗？

# Dubbo的缓存了解吗？


Dubbo负载均衡策略的了解

Dubbo服务治理的了解
14.为什么选择hessian，常用的通信框架有哪些？和google proto buffer有什么不同？

20.为什么要考虑netty？原理是什么？

Dubbo的底层实现原理和机制，

描述一个服务从发布到被消费的详细过程

*   fail-fast 与 fail-safe 机制有什么区别
4、Dubbo的底层原理，Zookeeper是什么
1、Dubbo超时重试；Dubbo超时时间设置

2、如何保障请求执行顺序

Dubbo的服务请求失败怎么处理
重连机制会不会造成错误

**1、****Dubbo超时重试；Dubbo超时时间设置**
Dubbo的服务请求失败怎么处理
11、dubbo如何一条链接并发多个调用。Dubbo的原理，序列化相关问题。

## dubbo 支持哪些序列化协议，hessian，说些hessian的 数据结构，pb知道吗，为啥pb 效率是最高的
## dubbo 负载均衡策略和高可用策略都有哪些，动态代理策略呢

