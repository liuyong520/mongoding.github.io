面试题-java 基础
===

**Java相关**


*   为什么要重写hashcode()和equals()以及他们之间的区别与关系； 

*   Object的hashcode()是怎么计算的？

*   若hashcode方法永远返回1或者一个常量会产生什么结果？ 


*   Java Collections和Arrays的sort方法默认的排序方法是什么； 

*   浅拷贝和深拷贝的区别； 

*   String s="abc"和String s=new String("abc")区别； 

*   HashSet方法里面的hashcode存在哪，如果重写equals不重写hashcode会怎么样？ 

*   反射的作用与实现原理； 

*   Java中的回调机制； 

*   模板方法模式； 

*   开闭原则说一下； 

**基础题**

*   怎么解决Hash冲突；（开放地址法、链地址法、再哈希法、建立公共溢出区等）

*   写出一个必然会产生死锁的伪代码；

*   Spring IoC涉及到的设计模式；（工厂模式、单利模式。。）

*   toString()方法什么情况下需要重写；

*   判断对象相等时，什么情况下只需要重写 equals()，什么情况下需要重写 equals(),hashcode()？

*   Set内存放的元素为什么不可以重复，内部是如何保证和实现的？

*   如何保证分布式缓存的一致性(分布式缓存一致性hash算法?)？分布式session实现？

*   Java 8流式迭代的好处？

*   项目中用到的JDK的哪些特性？

*   说一下TreeMap的实现原理？红黑树的性质？红黑树遍历方式有哪些？如果key冲突如何解决？setColor()方法在什么时候用？什么时候会进行旋转和颜色转换？

*   Spring的bean的创建时机？依赖注入的时机？

*   ArrayList和LinkList的删除一个元素的时间复杂度；（ArrayList是O(N)，LinkList是O(1)）；

*   CopyOnWriteArrayList是什么；

*   序列化和反序列化底层如何实现的（ObjectOutputStream 、ObjectInputStream、 readObject  writeObject）；

*   如何调试多线程的程序；

*   一个线程连着调用start两次会出现什么情况？（由于状态只有就绪、阻塞、执行，状态是无法由执行转化为执行的，所以会报不合法的状态！）

*   HashMap在什么时候时间复杂度是O（1），什么时候是O（n），什么时候又是O（logn）；

*   wait方法能不能被重写？（wait是final类型的，不可以被重写，不仅如此，notify和notifyall都是final类型的），wait能不能被中断；

*   一个Controller调用两个Service，这两Service又都分别调用两个Dao，问其中用到了几个数据库连接池的连接？
 


**基础题**

*   怎么解决Hash冲突；（开放地址法、链地址法、再哈希法、建立公共溢出区等）

*   写出一个必然会产生死锁的伪代码；

*   Spring IoC涉及到的设计模式；（工厂模式、单利模式。。）

*   toString()方法什么情况下需要重写；

*   判断对象相等时，什么情况下只需要重写 equals()，什么情况下需要重写 equals(),hashcode()？

*

*   Java 8流式迭代的好处？

*   项目中用到的JDK的哪些特性？


*   Spring的bean的创建时机？依赖注入的时机？


*   序列化和反序列化底层如何实现的（ObjectOutputStream 、ObjectInputStream、 readObject  writeObject）；

**Java相关**


*   char和double的字节，以及在内存的分布是怎样；



*   float f = 1.4f;double d = 1.4d; 与 float f = 1.5f;double d = 1.5d; 是否为true，内存是怎样的；

*   split的源码，split("a|b|c");得出多少个数组；


*   开闭原则，解析工厂方法模式，建造者模式，区别。手撸出来。

*   什么是敏捷开发，防御性编程，并行编程。Team Leader的思考;



*   写个后缀表达式，为什么要设计后缀表达式，有什么好处？然后写下中缀。


*   抽象方法和类方法的区别，static的抽象方法可以吗？

*   说下Java的克隆体系;



*   Java的多态怎么实现;

*   解释一下自旋;

*   解释一下信号量;


*   Java内存抖动严重，优化的思路；
**Java基础**






*   直接内存如何管理的；


*   让你设计一个cache如何设计；

*   String中hashcode是怎么实现的；

*   JDK中哪些实现了单例模式？




### **1.1、Java基础 **

*   面向对象的特征：继承、封装和多态

*   final, finally, finalize 的区别

*   Exception、Error、运行时异常与一般异常有何异同

*   请写出5种常见到的runtime exception

*   int 和 Integer 有什么区别，Integer的值缓存范围

*   包装类，装箱和拆箱

*   String、StringBuilder、StringBuffer

*   重载和重写的区别

*   抽象类和接口有什么区别

*   说说反射的用途及实现

*   说说自定义注解的场景及实现


*   列出自己常用的JDK包



*   equals与==的区别

*   hashCode和equals方法的区别与联系

*   什么是Java序列化和反序列化，如何实现Java序列化？或者请解释Serializable 接口的作用

*   Object类中常见的方法，为什么wait  notify会放在Object里边？

*   Java的平台无关性如何体现出来的

*   JDK和JRE的区别

*   Java 8有哪些新特性

11、.java如何实现多态

讲了下重载和重写

RMI的几种协议和实现框架
引用传递和值传递



4.知道java的异常吗？

5.运行时异常如果不处理会怎么样？应该怎么处理运行时异常？


dk1.8和jdk1.9的新特性

5，try  和final 中都有return 怎么返回的？


类是对象吗？类和对象有什么区别？

同步和异步处理有什么区别？




# equals重写有哪些需要注意的？
# 对象的详细创建过程了解吗？
# 反射的原理是什么？它的整个过程了解吗？



# JNDI了解吗？如何使用的？


JDK1.8有什么新特性 


String是基本类型吗，为什么可以用+操作 
两个方法完全相同可以重载吗，有什么办法可以 
try里面return，finally再return，哪个会返回，字节码怎么变的 

java有几种引用类型，什么情况下使用软引用，GC时如何判定哪些软引用需要回收 



String不可变的原理？

5、Java编程中，抽象类和接口的区别有哪些?


3.反射用到了哪些接口，哪些类？

4.反射机制中可以获取private成员的值吗？

*  

8、说说Java中异常的分类。

*   8、Java如何调用c、c++语言?
*   

17.  有没有遇到中文乱码问题，如何解决的

5.  高内聚，低耦合方面的理解

5.Java中实现多态的机制是什么；

6.如何将一个Java对象序列化到文件里；

7.说说你对Java反射的理解；

12.抽象类与接口的区别；应用场景；抽象类是否可以没有方法和属性；

13.静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

14.修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法；

15.说说你对泛型的了解；

16.Java的异常体系；


19.Dex加载过程和优化方式；
9、object类你知道的方法

10、hashcode和equals

11、你重写过hashcode和equals么，要注意什么

12、假设现在一个学生类，有学号和姓名，我现在hashcode方法重写的时候，只将学号参与计算，会出现什么情况？
1.  java中的引用有几种?

19.  `String`的+和`StringBuilder`有什么区别? 放在循环中有什么问题？
20.  日志打印的过程中，使用`String`的+操作和使用占位符输出，对性能上有什么区别
21.  `SimpleDateFormat`如果是一个全局变量的话，有什么问题？

## 4\. 了解响应式编程吗


## 14\. 自动装箱 Integer


## 3\. StringBuild String区别



Object类有哪些方法，clone方法的深拷贝和浅拷贝的区别，wait操作和sleep的操作的区别。


2、我们先聊聊java基础知识吧，说出Object类的常用方法？

toString()，clone（），线程的三个方法：wait（）notify（）notifyAll（），hashcode()，finallize(),equals()

大致讲了上面这些个方法 并说了下各个方法的作用。。。。

3、刚刚说到object的常用方法，这些方法你应该都很熟悉吧，那你说说你对equal和hashcode这两个方法的认识？

主要谈了下两个的作用 以及 当重写equal方法时候一定要记得重写hashcode方法，然后面试官就问了为什么，然后就继续巴拉巴拉。。。

然后面试官紧接着问 两个对象如果equals那么这两个对象的hashcode一定相等么 回答是！ 那如果两个对象的hashcode相等那么这两个对象是否一定equals?回答 不一定！理由其实 就是 关于 讲重写这两个方法的情况。。。。


11、.java如何实现多态

讲了下重载和重写










**异常**

**基本概念**

Error 和 Exception有什么区别
1.UnsupportedOperationException是什么
2.NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处

什么是受检查的异常，什么是运行时异常
运行时异常与一般异常有何异同
简述一个你最常见到的runtime exception(运行时异常)

**finally**

finally关键词在异常处理中如何使用
1.如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗
2.try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后
3.在什么情况下，finally语句不会执行

**throw 和 throws 有什么区别？
OOM你遇到过哪些情况？你是怎么搞定的？
SOF你遇到过哪些情况？
既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常
当自己创建异常类的时候应该注意什么
导致空指针异常的原因
异常处理 handle or declare 原则应该如何理解
怎么利用 JUnit 来测试一个方法的异常
catch块里别不写代码有什么问题
你曾经自定义实现过异常吗？怎么写的
什么是 异常链
在try块中可以抛出异常吗**

**JDBC**

通过 JDBC 连接数据库有哪几种方式
阐述 JDBC 操作数据库的基本步骤
JDBC 中如何进行事务处理
什么是 JdbcTemplate
什么是 DAO 模块
使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能
列出 5 个应该遵循的 JDBC 最佳实践

**IO**

**File**

File类型中定义了什么方法来创建一级目录
File类型中定义了什么方法来判断一个文件是否存在

**流**

为了提高读写性能，可以采用什么流
Java中有几种类型的流
JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类
对文本文件操作用什么I/O流
对各种基本数据类型和String类型的读写，采用什么流
能指定字符编码的 I/O 流类型是什么

**序列化**

什么是序列化？如何实现 Java 序列化及注意事项
Serializable 与 Externalizable 的区别

**Socket**

socket 选项 TCP NO DELAY 是指什么
Socket 工作在 TCP/IP 协议栈是哪一层
TCP、UDP 区别及 Java 实现方式

说几点 IO 的最佳实践
直接缓冲区与非直接缓冲器有什么区别？
怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么
当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少
如何使用扫描器类（Scanner Class）令牌化

**面向对象编程（OOP）**

解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）
多态的实现原理
封装、继承和多态是什么
对象封装的原则是什么?

**类** 

获得一个类的类对象有哪些方式
重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
说出几条 Java 中方法重载的最佳实践

**抽象类** 

抽象类和接口的区别
抽象类中是否可以有静态的main方法
抽象类是否可实现(implements)接口
抽象类是否可继承具体类(concrete class)

**匿名类（Anonymous Inner Class）** 

匿名内部类是否可以继承其它类？是否可以实现接口

**内部类** 

内部类分为几种
内部类可以引用它的包含类（外部类）的成员吗
请说一下 Java 中为什么要引入内部类？还有匿名内部类

**继承**

继承（Inheritance）与聚合（Aggregation）的区别在哪里
继承和组合之间有什么不同
为什么类只能单继承，接口可以多继承
存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B
如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题


8、介绍一下 Hash，怎么解决冲突。




16.正则表达式

\s表示所有空白字符；\S表示非空白字符；*表示匹配零次或多次；+表示匹配一次或多次；. 表示除换行符外的任意字符；？匹配零次或一次。

1.如何停止运行一个线程 

interrupt

2.如何实现一个hashmap，需要考虑哪些问题 

hashcode

3.equal和==的区别 

值类型是存储在内存中的堆栈（以后简称栈），而引用类型的变量在栈中仅仅是存储引用类型变量的地址，而其本身则存储在堆中。

==操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。

    equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。

String s2 = new String("Monday").intern();会放入缓冲池。

4.如何判断一个对象已经被回收 

12.Java有没有多继承，接口和抽象类区别。jvm 理解

接口可以多继承，类不可以。

（1）抽象类是由abstract关键字修饰，允许包含未实现的方法。

接口是方法声明和常量值定义的集合，不允许包含变量。

（2）接口是绝对抽象的，不可以被实例化。抽象类不能被实例化。

（3）定义接口时可以使用继承，而且可以使用多继承。抽象类只能单继承。类可以实现很多个接口，但是只能继承一个抽象类；

（4）接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。

（5）Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。

类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

public是在不同包中也可以访问；protected是必须在同一个包中或者子类才能访问；default是不允许子类访问，可以在类内部或者同一个包中访问；private是只能在类内部访问。

13.JDK和JRE的区别是什么？

Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK) 是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程 序。

JDK中包含JRE，JRE中包含JVM。

JDK中包含的JRE主要是为JDK自带的开发工具提供运行环境，与JDK并列的那个JRE是为用户编写的JAVA代码提供运行环境的。

classpath配置的是JDK的lib目录，path配置的是JDK的bin目录。



重写和重载

（1）重写：需要继承；方法吗和参数、返回值必须相同，权限修饰符必须大于等于父类；不可以重写父类的private方法；不可以抛出父类没有抛出的异常；

（2）重载：方法名必须相同；参数个数、类型有一个不相同；返回值可以相同也可以不同；可以有不同的访问修饰符；可以抛出不同异常。


6、有一个整数，转换为二进制，请找出所有的1的数量；

只计算1的个数使用：

while(n>0)

count++;

n = n & (n-1);

7、你觉得Java是完全面相对象的语言吗？

8、讲解下你对抽象，多态的理解；

抽象就是将实际事物特征抽象出来，用一个类表示，类中的属性就表示事物的不同特征。

抽象类和接口就是抽象的一种表象。

多态

①使用父类类型的引用指向子类的对象；

②该引用只能调用父类中定义的方法，不能调用子类中独有的方法；

③如果子类中重写了父类中的一个方法，那么在调用该方法的时候，将会调用子类中的这个方法；

④在多态中，子类可以调用父类中的所有方法；

⑤多态主要体现为方法重载和方法重写，相同的行为，不同的实现方式；

⑥多态的主要应用是多态参数和多态集合

⑦如果一个方法中有父类作为参数类型，就意味着可以给该方法传递任何一个子类对象。

日期

*   计算两个日期之间的差距

1.关键字transient

1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。

2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。

3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。



*   将一个键盘输入的数字转化成中文输出(例如：输入1234567，输出:一百二拾三万四千五百六拾七)

*   在Web应用开发过程中经常遇到输出某种编码的字符，如从 GBK 到 ISO8859-1等，如何输出一个某种编码的字符串
正则

*   请编写一段匹配IP地址的正则表达式

*   写出一个正则表达式来判断一个字符串是否是一个数字

字符串

*   写一段代码在遍历 ArrayList 时移除一个元素
反射

*   反射机制提供了什么功能？

*   反射是如何实现的

*   哪里用到反射机制

*   反射中 Class.forName 和 ClassLoader 区别

*   反射创建类实例的三种方式是什么

*   如何通过反射调用对象的方法

*   如何通过反射获取和设置对象私有字段的值

*   反射机制的优缺点

网络

*   用Java Socket编程，读服务器几个字符，再写入本地显示
*   是否看过框架的一些代码

*   持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些

*   数值提升是什么

*   你能解释一下里氏替换原则吗

*   你是如何测试一个应用的？知道哪些测试框架

*   传输层常见编程协议有哪些？并说出各自的特点

*   什么是领域模型(domain model)？贫血模型(anaemic domain model) 和充血模型(rich domain model)有什么区别

*   什么是领域驱动开发（Domain Driven Development）

*   介绍一下了解的 Java 领域的 Web Service 框架

*   Web Server、Web Container 与 Application Server 的区别是什么

*   微服务（MicroServices）与巨石型应用（Monolithic Applications）之间的区别在哪里



*   Java 9 带来了怎样的新功能

*   Java 与 C++ 对比，C++ 或 Java 中的异常处理机制的简单原理和应用

* 
*   Java解析XML的方式

*   用 jdom 解析 xml 文件时如何解决中文问题？如何解析

*   你在项目中用到了 XML 技术的哪些方面？如何实现


开放问题

*   Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？
说几点 IO 的最佳实践

直接缓冲区与非直接缓冲器有什么区别？

怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么

当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少

如何使用扫描器类（Scanner Class）令牌化

面向对象编程（OOP）

*   解释下多态性（polymorphism），封装性（encapsulation），内聚（cohesion）以及耦合（coupling）

*   多态的实现原理

*   封装、继承和多态是什么

*   对象封装的原则是什么?

*   类

1.  获得一个类的类对象有哪些方式

2.  重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？

3.  说出几条 Java 中方法重载的最佳实践

*   抽象类

1.  抽象类和接口的区别

2.  抽象类中是否可以有静态的main方法

3.  抽象类是否可实现(implements)接口

4.  抽象类是否可继承具体类(concrete class)

*   匿名类（Anonymous Inner Class）

1.  匿名内部类是否可以继承其它类？是否可以实现接口 

*   内部类

1.  内部类分为几种

2.  内部类可以引用它的包含类（外部类）的成员吗

3.  请说一下 Java 中为什么要引入内部类？还有匿名内部类

*   继承

1.  继承（Inheritance）与聚合（Aggregation）的区别在哪里

2.  继承和组合之间有什么不同

3.  为什么类只能单继承，接口可以多继承

4.  存在两个类，B 继承 A，C 继承 B，能将 B 转换为 C 么？如 C = (C) B

5.  如果类 a 继承类 b，实现接口c，而类 b 和接口 c 中定义了同名变量，请问会出现什么问题

*   接口

1.  接口是什么

2.  接口是否可继承接口

3.  为什么要使用接口而不是直接使用具体类？接口有什么优点

泛型

*   泛型的存在是用来解决什么问题

*   泛型的常用特点

*   List能否转为List

工具类

日历

*   Calendar Class的用途

*   如何在Java中获取日历类的实例

*   解释一些日历类中的重要方法

*   GregorianCalendar 类是什么

*   SimpleTimeZone 类是什么

*   Locale类是什么

*   如何格式化日期对象

*   如何添加小时(hour)到一个日期对象(Date Objects)

*   如何将字符串 YYYYMMDD 转换为日期
11.  如何确保 main() 方法所在的线程是 Java 程序最后结束的线程

12.  非常多个线程（可能是不同机器），相互之间需要等待协调才能完成某种工作，问怎么设计这种协调方案

13.  你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它

异常

基本概念

*   Error 和 Exception有什么区别

1.  UnsupportedOperationException是什么

2.  NullPointerException 和 ArrayIndexOutOfBoundException 之间有什么相同之处

*   什么是受检查的异常，什么是运行时异常                                                                                                                                                                      答案：
    Java提供了两类主要的异常 :runtime exception和checked exception。 checked异常也就是我们经常遇到的IO异常，以及SQL异常都是这种异常。 对于这种异常， JAVA编译器强制要求我们必需对出现的这些异常进行catch 。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 这类异常一般是外部错误,例如试图从文件尾后读取数据等,这并不是程序本身的错误,而是在应用环境中出现的外部错误. 但是另外一种异常： runtime exception ，也称运行时异常，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过 NullPointerException 异常，它就是运行时异常，并且这种异常还是最常见的异常之一。                                                                                

*   运行时异常与一般异常有何异同

*   简述一个你最常见到的runtime exception(运行时异常)

finally

*   finally关键词在异常处理中如何使用

1.  如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗

2.  try里有return，finally还执行么？那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后

3.  在什么情况下，finally语句不会执行

throw 和 throws 有什么区别？


SOF你遇到过哪些情况？

既然我们可以用RuntimeException来处理错误，那么你认为为什么Java中还存在检查型异常

当自己创建异常类的时候应该注意什么

导致空指针异常的原因

异常处理 handle or declare 原则应该如何理解

怎么利用 JUnit 来测试一个方法的异常

catch块里别不写代码有什么问题

你曾经自定义实现过异常吗？怎么写的

什么是 异常链

在try块中可以抛出异常吗

JDBC

*   通过 JDBC 连接数据库有哪几种方式

*   阐述 JDBC 操作数据库的基本步骤

*   JDBC 中如何进行事务处理

*   什么是 JdbcTemplate

*   什么是 DAO 模块

*   使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能

*   列出 5 个应该遵循的 JDBC 最佳实践

IO

File

*   File类型中定义了什么方法来创建一级目录

*   File类型中定义了什么方法来判断一个文件是否存在

流

*   为了提高读写性能，可以采用什么流

*   Java中有几种类型的流

*   JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类

*   对文本文件操作用什么I/O流

*   对各种基本数据类型和String类型的读写，采用什么流

*   能指定字符编码的 I/O 流类型是什么

序列化

*   什么是序列化？如何实现 Java 序列化及注意事项

*   Serializable 与 Externalizable 的区别

Socket

*   socket 选项 TCP NO DELAY 是指什么

*   Socket 工作在 TCP/IP 协议栈是哪一层

*   TCP、UDP 区别及 Java 实现方式



 

*   如果main方法被声明为private会怎样
*   我们能否重载main()方法

6.以前有没有用过Java枚举


2\. Java是用哪种字符集进行编码的？


5\. 不想进行序列化，用哪个关键字



9\. Java如何实现夸平台






7、Java运行时数据区域画出来，如果有一个对象有一个域是String s = “abc”；，这个s在哪里，“abc”在哪里

2、Java反射熟悉吗？如何访问一个类的私有成员？私有函数呢？





你说你熟悉Java基础，那讲一讲int与Integer的区别。我特意解释了拆箱装箱、Integer的一些源码、泛型的应用。


1.String类为什么是final的。


3.反射中，Class.forName和classloader的区别





7.Java7、Java8的新特性(baidu问的,好BT)

8.Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高


finalize

*   什么是finalize()方法

1.  finalize()方法什么时候被调用

2.  析构函数(finalization)的目的是什么

3.  final 和 finalize 的区别

4.  final

*   final关键字有哪些用法

1.  final 与 static 关键字可以用于哪里？它们的作用是什么

2.  final, finally, finalize的区别

3.  final、finalize 和 finally 的不同之处？

*   能否在运行时向 static final 类型的赋值

1.  使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变

使用final关键字修饰一个引用变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。 

1.  一个类被声明为final类型，表示了什么意思

认为该类已经达到完美，完全没有必要再去修改它，用final关键字。
不希望该类被继承，用final关键字修饰。

1.  throws, throw, try, catch, finally分别代表什么意义

Java 有几种修饰符？分别用来修饰什么

volatile

*   volatile 修饰符的有过什么实践

答：1，线程1执行doWork()的过程中，可能有另外的线程2调用了shutdown，所以boolean变量必须是volatile。

     2，独立观察，定期 “发布” 观察结果供程序内部使用。【例如】假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。

     3，线程安全的计数器，使用 `synchronized` 确保增量操作是原子的，并使用 `volatile` 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。

     4，单例双检锁

   总结一下，可以分为5个：作为状态位发布；一次性安全发布；独立观察；volatile bean模式；开销较低的读写锁策略。

*   volatile 变量是什么？volatile 变量和 atomic 变量有什么不同 

答：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
        2）禁止进行指令重排序。

```java
//线程1boolean stop = false;while(!stop){    doSomething();} //线程2stop = true;
```

这个代码能够把线程中断，但是也有可能会导致无法中断线程。每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。但是用volatile修饰之后就变得不一样了：第一：使用volatile关键字会强制将修改的值立即写入主存；第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。那么线程1读取到的就是最新的正确的值。
happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。

*   volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗

答:volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。

某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。

volatile修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性： 

*   能创建 volatile 数组吗？

答： volatile修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性

：

transient变量有什么特点

答：

我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。

      然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。

1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。

2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。

3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。

super什么时候使用

答：子类的构造函数中不是必须使用super，在[构造函数](https://www.baidu.com/s?wd=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d-uj6zPvR1nWTYPhDLmvR0IAYqnWm3PW64rj0d0AP8IA3qPjfsn1bkrjKxmLKz0ZNzUjdCIZwsrBtEXh9GuA7EQhF9pywdQhPEUiqkIyN1IA-EUBtznjfsn1Dznjb)中,如果第一行没有写super(),编译器会自动插入.但是如果父类没有不带参数的构造函数,或这个函数被私有化了(用private修饰).此时你必须加入对父类的实例化构造.而this就没有这个要求,因为它本身就进行实例化的构造.

 如果父类的构造函数是无参的，那子类构造函数会在第一行默认调用super().

     下面这种情况是必须调用super()的：

```java
 1 public class Father { 2      public String name; 3      public Father(String name) { 4             this.name = name; 5     } 6 } 7  8 class Son extends Father{ 9       public Son(String name) {10             super(name);11 }12 //必须调用，否则他会默认调用父类的无参构造函数，而父类的无参构造函数已经被有参的覆盖，所以找不到
```

public static void 写成 static public void会怎样

说明一下public static void main(String args[])这段声明里每个关键字的作用

请说出作用域public, private, protected, 以及不写时的区别

sizeof 是Java 的关键字吗

static

*   static class 与 non static class的区别

内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。  
非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。  
一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。 

*   static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法

Static表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。 重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，private修饰不支持继承，因此被私有的方法不可以被重写。静态方法形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写。 

*   静态类型有什么特点

答案：1、随着类的加载而加载
也就是说：静态会随着类的消失而消失，说明他的生命周期最长
2、优先于对象存在
3、被所有对象所共享
4、可以直接被类名调用 

*   main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态

答案：所有static成员都是在程序装载时初始化的，被分配在一块静态存储区域。这个区域的成员一旦被分配，就不再改变地址啦。直到程序结束才释放。main（）就存储在这里。尽管包含main()的类还没有被实例化，但是main()方法已经可以使用啦。而且JVM将会自动调用这个方法。通过main()的调用，再实例化其他的对象，也包括自己所在的类。 

*   是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用

*   静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢

答案：当类加载器将类加载到JVM中的时候就会创建静态变量，这跟对象是否创建无关。静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次。一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用。静态代码块不能包含this或者super,它们通常被用初始化静态变量。 

*   成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量

答案：可以。static成员是在JVM的CLASSLOADER加载类的时候初始化的，而非static的成员是在创建对象，即new 操作的时候才初始化的；类加载的时候初始化static的成员，此时static 已经分配内存空间，所以可以访问；非static的成员还没有通过new创建对象而进行初始化，所以必然不可以访问。
简单点说：静态成员属于类,不需要生成对象就存在了.而非静态需要生成对象才产生，所以静态成员不能直接访问. 

switch

*   switch 语句中的表达式可以是什么类型数据

*   switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上

*   while 循环和 do 循环有什么不同

操作符

*   &操作符和&&操作符有什么区别?

*   a = a + b 与 a += b 的区别？

*   逻辑操作符 (&,|,^)与条件操作符(&&,||)的区别

*   3*0.1 == 0.3 将会返回什么？true 还是 false？

*   float f=3.4; 是否正确？

*   short s1 = 1; s1 = s1 + 1;有什么错?

数据结构

基础类型(Primitives)

*   基础类型(Primitives)与封装类型(Wrappers)的区别在哪里

*   简述九种基本数据类型的大小，以及他们的封装类

*   int 和 Integer 哪个会占用更多的内存？ int 和 Integer 有什么区别？parseInt()函数在什么时候使用到

*   float和double的默认值是多少

*   如何去小数四舍五入保留小数点后两位

*   char 型变量中能不能存贮一个中文汉字，为什么

类型转换

*   怎样将 bytes 转换为 long 类型

*   怎么将 byte 转换为 String

*   如何将数值型字符转换为数字

*   我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象

*   能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗

*   类型向下转换是什么

数组

*   如何权衡是使用无序的数组还是有序的数组                                                                                                                                                                  答案：
    有序数组最大的好处：在于查找的时间复杂度是O(log n)，而无序数组是O(n)。
    有序数组的缺点是：插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。                                                                                                                                                                                                                           

*   怎么判断数组是 null 还是为空

*   怎么打印数组？ 怎样打印数组中的重复元素

*   Array 和 ArrayList有什么区别？什么时候应该使用Array而不是ArrayList                                                                                                                      答案：
    Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
    Array大小是固定的，ArrayList的大小是动态变化的。
    ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
    对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。                           

*   数组和链表数据结构描述，各自的时间复杂度                                                                                                                                                               答案：
    1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；　
    2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；　
    3、存储空间上，链表由于带有指针域，存储密度不如数组大；　
    4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　
    5、按值查找时，若数组无序，数组和链表时间复杂度均为O(n)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；　
    6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；　
    7、空间分配方面： 
    　　数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败； 
    　　链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；                                                                 

*   数组有没有length()这个方法? String有没有length()这个方法


Hash算法

*   Hashcode 的作用

*   简述一致性 Hash 算法                                                                                                                                                                                                  答案：一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：
    1、平衡性(Balance)
    2、单调性(Monotonicity)
    3、分散性(Spread)
    4、负载(Load)
    普通的哈希算法（也称硬哈希）采用简单取模的方式，将机器进行散列，这在cache环境不变的情况下能取得让人满意的结果，但是当cache环境动态变化时，这种静态取模的方式显然就不满足单调性的要求（当增加或减少一台机子时，几乎所有的存储内容都要被重新散列到别的缓冲区中）。
    一致性哈希算法的基本实现原理是将机器节点和key值都按照一样的hash算法映射到一个0~2^32的圆环上。当有一个写入缓存的请求到来时，计算Key值k对应的哈希值Hash(k)，如果该值正好对应之前某个机器节点的Hash值，则直接写入该机器节点，如果没有对应的机器节点，则顺时针查找下一个节点，进行写入，如果超过2^32还没找到对应节点，则从0开始查找(因为是环状结构)。                                                                          

*   有没有可能 两个不相等的对象有相同的 hashcode？当两个对象 hashcode 相同怎么办？如何获取值对象                                                                答案：有。                                                                                                                                                                                                                   可以用equal比较值。                                                                                                                                                                                                    

*   为什么在重写 equals 方法的时候需要重写 hashCode 方法？equals与 hashCode 的异同点在哪里

*   a.hashCode() 有什么用？与 a.equals(b) 有什么关系                                                                                                                                                   答案：

    1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；

    2、如果两个对象相同，就是适用于equals([Java](http://lib.csdn.net/base/java "Java 知识库").lang.Object) 方法，那么这两个对象的hashCode一定要相同；

    3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；

    4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

    再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。                                                                                     

*   hashCode() 和 equals() 方法的重要性体现在什么地方

*   Object：Object有哪些公用方法？Object类hashcode,equals 设计原则？ sun为什么这么设计？Object类的概述                                                  答案：clone，getClass, toString, finalize, equal, hashCode,wait,notify, notifyAll                                                                                              Object类是所有Java类的祖先。每个类都使用 Object 作为[超类](https://baike.baidu.com/item/%E8%B6%85%E7%B1%BB)。所有对象（包括[数组](https://baike.baidu.com/item/%E6%95%B0%E7%BB%84)）都[实现](https://baike.baidu.com/item/%E5%AE%9E%E7%8E%B0/10801654)这个[类](https://baike.baidu.com/item/%E7%B1%BB/33969)的方法。                                                                                  

*   如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。

*   可以在 hashcode() 中使用随机数字吗？

答案：不可以。Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。                                                                                                                                                


*   Comparator 与 Comparable 接口是干什么的？列出它们的区别                                                                                                                                   答案：
    1,Comparable
    Comparable 定义在 Person类的内部:
    public class Persion implements Comparable {..比较Person的大小..},
     因为已经实现了比较器,那么我们的Person现在是一个可以比较大小的对象了,它的比较功能和String完全一样,可以随时随地的拿来
    比较大小,因为Person现在自身就是有大小之分的。Collections.sort(personList)可以得到正确的结果。

    2,Comparator
    Comparator 是定义在Person的外部的, 此时我们的Person类的结构不需要有任何变化,如
    public class Person{ String name; int age },
    然后我们另外定义一个比较器:
    public PersonComparator implements Comparator() {..比较Person的大小..},
    在PersonComparator里面实现了怎么比较两个Person的大小. 所以,用这种方法,当我们要对一个 personList进行排序的时候, 
    我们除了了要传递personList过去, 还需要把PersonComparator传递过去,因为怎么比较Person的大小是在PersonComparator
    里面实现的, 如:
    Collections.sort( personList , new PersonComparator() ).                     

对象

拷贝(clone)

*   如何实现对象克隆

*   深拷贝和浅拷贝区别

*   深拷贝和浅拷贝如何实现激活机制

*   写clone()方法时，通常都有一行代码，是什么

比较

*   在比较对象时，”==” 运算符和 equals 运算有何区别

*   如果要重写一个对象的equals方法，还要考虑什么

*   两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对

构造器

*   构造器链是什么

*   创建对象时构造器的调用顺序

不可变对象

*   什么是不可变象（immutable object）

*   为什么 Java 中的 String 是不可变的（Immutable）

*   如何构建不可变的类结构？关键点在哪里

*   能创建一个包含可变对象的不可变对象吗

如何对一组对象进行排序

方法

*   构造器（constructor）是否可被重写（override）

*   方法可以同时即是 static 又是 synchronized 的吗

*   abstract 的 method是否可同时是 static，是否可同时是 native，是否可同时是synchronized                                                                                       答案：都不可以，因为abstract申明的方法是要求子类去实现的，abstract只是告诉你有这样一个接口，你要去实现，至于你的具体实现可以是native和synchronized，也可以不是，抽象方法是不关心这些事的，所以写这两个是没有意义的。然后，static方法是不会被覆盖的，而abstract方法正是要子类去覆盖它，所以也是没有意义的。所以，总的来说，就是java语法不允许你这样做，事实上，也没有意义这样做。
    abstract需要重载,static为类方法,没有重载一说 abstract为没有实现的方法,native为本机实现的方法,自相矛盾 abstract方法没有实现,也不可能实际调用抽象方法,没有必要synchronized修饰,当然子类可以根据需要同步该方法.所以 都不能。                                                                                      

*   Java支持哪种参数传递类型                                                                                                                                                                                           答案：Java 应用程序有且仅有的一种参数传递机制，即按值传递。
    对象是按引用传递的；
    Java 应用程序有且仅有的一种参数传递机制，即按值传递；
    按值传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的一个副本；
    按引用传递意味着当将一个参数传递给一个函数时，函数接收的是原始值的内存地址，而不是值的副本。                                                                 

*   一个对象被当作参数传递到一个方法，是值传递还是引用传递                                                                                                                                       答案：是值传递。Java编程语言中只有由值传递参数的。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。                                                                                                                      

*   当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递


RMI与代理模式


*   一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制

*   RPC 通信和 RMI 区别
*   IO 和 NIO的区别，NIO优点

*   Java 8 / Java 7 为我们提供了什么新功能


5、Java中对异常时如何进行分类的？

异常整体分类：

1）Java异常结构中定义有Throwable类。 Exception和Error为其子类。

2）其中Exception表示由于网络故障、文件损坏、设备错误、用户输入非法情况导致的异常；

3）而Error标识Java运行时环境出现的错误，例如：JVM内存耗尽。





3、jvm，jre以及jdk三者之间的关系？




12、说出一些常用的类，包，接口，请各举5个

常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer

常用的包：java.lang java.awt java.io java.util java.sql

常用的接口：Remote List Map Document NodeList


8、在JAVA中，如何跳出当前的多重嵌套循环？

用break; return 方法。




2、java中实现多态的机制是什么？

方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。


4、静态变量和实例变量的区别？

static i = 10; //常量

class A a; a.i =10;//可变


5、什么是java序列化，如何实现java序列化？

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。

序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。

6、是否可以从一个static方法内部发出对非static方法的调用？

不可以,如果其中包含对象的method()；不能保证对象初始化.

7、写clone()方法时，通常都有一行代码，是什么？

Clone 有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。





*   如何将一个Java对象序列化到文件里；

*   说说你对Java反射的理解； 答：Java 中的反射首先是能够获取到Java 中要反射类的字节码， 获取字节码有三种方法，
    1.Class.forName(className) 2.类名.class 3.this.getClass()。然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor 等类，这些类提供了丰富的方法可以被我们所使用。

*   String StringBuilder StringBuffer对比；

*   Java如何调用c、c++语言；

*   接口与回调；回调的原理；写一个回调demo；

*   泛型原理，举例说明；解析与分派；

*   抽象类与接口的区别；应用场景；抽象类是否可以没有方法和属性；

*   静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

*   修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法；

*   说说你对泛型的了解；

*   Java的异常体系；


*   常见编码方式；utf-8编码中的中文占几个字节；int型几个字节；





*   string分析1000次循环subString用了多少内存；

1、开发中Java用了比较多的数据结构有哪些？


12、object类你知道的方法

1、面向对象的基本特征


2、String，StringBuffer ,StringBuilder的区别

8、说说你常见到的异常，什么情况下会出现，怎么解决



1、StringBuilder内部是怎样实现的，初始的字符数组长度是多少，怎么扩容

7、Java代码中怎样释放一个对象
2.static关键字的作用
3\. final 修饰 属性 类 方法都有什么作用
4\. abstract 等关键字的作用，什么时候用
5.子类中如何调用父类的构造器，如果不用super关键字呢?有其他的方式吗?


2、字符串哈希相等，equals相等吗？反过来呢？

10\. 两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化
116\. java的反射是如何实现的
114\. 类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？
String 转出 int型，判断能不能转？如何转？ 
包装类型和基本类型比较问题（例如，Integer类型的变量能否==int类型变量，能否作比较，什么时候不能作比较）

一个包装对象和一个基本类型的值进行比较是比较值，而不是比较引用。
反射机制中可以获取private成员的值吗（没有set和get函数）
1.  String是基本类型吗，为什么可以用+操作

2.  两个方法完全相同可以重载吗，有什么办法可以

3.  try里面return，finally再return，哪个会返回，字节码怎么变的

4.  java有几种引用类型，什么情况下使用软引用，GC时如何判定哪些软引用需要回收

21.静态类与单例模式的区别

单例模式比静态类有很多优势：

（1）单例可以继承类，实现接口，而静态类不能（可以集成类，但不能集成实例成员）；

（2）单例可以被延迟初始化，静态类一般在第一次加载是初始化；

（3）单例类可以被集成，他的方法可以被覆写；

（4）或许最重要的是，单例类可以被用于多态而无需强迫用户只假定唯一的实例。举个例子，你可能在开始时只写一个配置，但是以后你可能需要支持超过一个配置集，或者可能需要允许用户从外部文件中加载一个配置对象，或者编写自己的。你的代码不需要关注全局的状态，因此你的代码会更加灵活。

观点二：（静态方法）静态方法中产生的对象，会随着静态方法执行完毕而释放掉，而且执行类中的静态方法时，不会实例化静态方法所在的类。如果是用singleton, 产生的那一个唯一的实例，会一直在内存中，不会被GC清除的(原因是静态的属性变量不会被GC清除)，除非整个JVM退出了。这个问题我之前也想几天，并 且自己写代码来做了个实验。

观点三：（Good！）

由于DAO的初始化，会比较占系统资源的，如果用静态方法来取，会不断地初始化和释放，所以我个人认为如果不存在比较复杂的事务管理，用singleton会比较好。
5.运行时异常如果不处理会怎么样？应该怎么处理运行时异常？

不会怎么样，会在运行的时候出错。（RuntimeError是uncheck异常，所以不需要捕获）
4、String s = “123”;这个语句有几个对象产生 
s是引用或者叫做句柄。  
java语言中有一个常量池，如果在你的代码的其它地方已经定义过这么这个’123’的变量，在定义string s=’123’的时候，直接把s指向常量池中的字符串123，就不会新生成一个字符串123，但假如没有的话，就会新生成一个字符串123，指向s，并放入常量池！ 
String s = new String(“123”);有区别的，这句两个对象（一个堆中的对象，一个常量池里的对象）。
9、Object类中有哪些方法，列举3个以上（可以引导） 
基本数据类型不会继承Object类 
clone() 
finalize() 
toString() 
equals() 
hashCode() 
10、char型变量中能不能存贮一个中文汉字?为什么? 
char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字， 
 所以，char型变量中当然可以存储汉字。不过，如果某个特殊的汉字没有被包含在 
  unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充 
 说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 
char表示的范围是0–65535
1.  java内部类为什么可以访问外部类的属性成员
Error与RuntimeException的区别

##  Java中实现多态的机制是什么；







